// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stremio/core/runtime/event.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Stremio_Core_Runtime_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var profilePushedToStorage: Stremio_Core_Runtime_Event.ProfilePushedToStorage {
    get {
      if case .profilePushedToStorage(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.ProfilePushedToStorage()
    }
    set {_uniqueStorage()._type = .profilePushedToStorage(newValue)}
  }

  public var libraryItemsPushedToStorage: Stremio_Core_Runtime_Event.LibraryItemsPushedToStorage {
    get {
      if case .libraryItemsPushedToStorage(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibraryItemsPushedToStorage()
    }
    set {_uniqueStorage()._type = .libraryItemsPushedToStorage(newValue)}
  }

  public var streamsPushedToStorage: Stremio_Core_Runtime_Event.StreamsPushedToStorage {
    get {
      if case .streamsPushedToStorage(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.StreamsPushedToStorage()
    }
    set {_uniqueStorage()._type = .streamsPushedToStorage(newValue)}
  }

  public var searchHistoryPushedToStorage: Stremio_Core_Runtime_Event.SearchHistoryPushedToStorage {
    get {
      if case .searchHistoryPushedToStorage(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.SearchHistoryPushedToStorage()
    }
    set {_uniqueStorage()._type = .searchHistoryPushedToStorage(newValue)}
  }

  public var notificationsPushedToStorage: Stremio_Core_Runtime_Event.NotificationsPushedToStorage {
    get {
      if case .notificationsPushedToStorage(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.NotificationsPushedToStorage()
    }
    set {_uniqueStorage()._type = .notificationsPushedToStorage(newValue)}
  }

  public var dismissedEventsPushedToStorage: Stremio_Core_Runtime_Event.DismissedEventsPushedToStorage {
    get {
      if case .dismissedEventsPushedToStorage(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.DismissedEventsPushedToStorage()
    }
    set {_uniqueStorage()._type = .dismissedEventsPushedToStorage(newValue)}
  }

  public var userPulledFromApi: Stremio_Core_Runtime_Event.UserPulledFromAPI {
    get {
      if case .userPulledFromApi(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.UserPulledFromAPI()
    }
    set {_uniqueStorage()._type = .userPulledFromApi(newValue)}
  }

  public var userPushedToApi: Stremio_Core_Runtime_Event.UserPushedToAPI {
    get {
      if case .userPushedToApi(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.UserPushedToAPI()
    }
    set {_uniqueStorage()._type = .userPushedToApi(newValue)}
  }

  public var addonsPulledFromApi: Stremio_Core_Runtime_Event.AddonsPulledFromAPI {
    get {
      if case .addonsPulledFromApi(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.AddonsPulledFromAPI()
    }
    set {_uniqueStorage()._type = .addonsPulledFromApi(newValue)}
  }

  public var addonsPushedToApi: Stremio_Core_Runtime_Event.AddonsPushedToAPI {
    get {
      if case .addonsPushedToApi(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.AddonsPushedToAPI()
    }
    set {_uniqueStorage()._type = .addonsPushedToApi(newValue)}
  }

  public var librarySyncWithApiPlanned: Stremio_Core_Runtime_Event.LibrarySyncWithAPIPlanned {
    get {
      if case .librarySyncWithApiPlanned(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibrarySyncWithAPIPlanned()
    }
    set {_uniqueStorage()._type = .librarySyncWithApiPlanned(newValue)}
  }

  public var libraryItemsPushedToApi: Stremio_Core_Runtime_Event.LibraryItemsPushedToAPI {
    get {
      if case .libraryItemsPushedToApi(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibraryItemsPushedToAPI()
    }
    set {_uniqueStorage()._type = .libraryItemsPushedToApi(newValue)}
  }

  public var libraryItemsPulledFromApi: Stremio_Core_Runtime_Event.LibraryItemsPulledFromAPI {
    get {
      if case .libraryItemsPulledFromApi(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibraryItemsPulledFromAPI()
    }
    set {_uniqueStorage()._type = .libraryItemsPulledFromApi(newValue)}
  }

  public var userAuthenticated: Stremio_Core_Runtime_Event.UserAuthenticated {
    get {
      if case .userAuthenticated(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.UserAuthenticated()
    }
    set {_uniqueStorage()._type = .userAuthenticated(newValue)}
  }

  public var userAddonsLocked: Stremio_Core_Runtime_Event.UserAddonsLocked {
    get {
      if case .userAddonsLocked(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.UserAddonsLocked()
    }
    set {_uniqueStorage()._type = .userAddonsLocked(newValue)}
  }

  public var userLibraryMissing: Stremio_Core_Runtime_Event.UserLibraryMissing {
    get {
      if case .userLibraryMissing(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.UserLibraryMissing()
    }
    set {_uniqueStorage()._type = .userLibraryMissing(newValue)}
  }

  public var userLoggedOut: Stremio_Core_Runtime_Event.UserLoggedOut {
    get {
      if case .userLoggedOut(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.UserLoggedOut()
    }
    set {_uniqueStorage()._type = .userLoggedOut(newValue)}
  }

  public var sessionDeleted: Stremio_Core_Runtime_Event.SessionDeleted {
    get {
      if case .sessionDeleted(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.SessionDeleted()
    }
    set {_uniqueStorage()._type = .sessionDeleted(newValue)}
  }

  public var traktAddonFetched: Stremio_Core_Runtime_Event.TraktAddonFetched {
    get {
      if case .traktAddonFetched(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.TraktAddonFetched()
    }
    set {_uniqueStorage()._type = .traktAddonFetched(newValue)}
  }

  public var traktLoggedOut: Stremio_Core_Runtime_Event.TraktLoggedOut {
    get {
      if case .traktLoggedOut(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.TraktLoggedOut()
    }
    set {_uniqueStorage()._type = .traktLoggedOut(newValue)}
  }

  public var addonInstalled: Stremio_Core_Runtime_Event.AddonInstalled {
    get {
      if case .addonInstalled(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.AddonInstalled()
    }
    set {_uniqueStorage()._type = .addonInstalled(newValue)}
  }

  public var addonUpgraded: Stremio_Core_Runtime_Event.AddonUpgraded {
    get {
      if case .addonUpgraded(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.AddonUpgraded()
    }
    set {_uniqueStorage()._type = .addonUpgraded(newValue)}
  }

  public var addonUninstalled: Stremio_Core_Runtime_Event.AddonUninstalled {
    get {
      if case .addonUninstalled(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.AddonUninstalled()
    }
    set {_uniqueStorage()._type = .addonUninstalled(newValue)}
  }

  public var settingsUpdated: Stremio_Core_Runtime_Event.SettingsUpdated {
    get {
      if case .settingsUpdated(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.SettingsUpdated()
    }
    set {_uniqueStorage()._type = .settingsUpdated(newValue)}
  }

  public var libraryItemAdded: Stremio_Core_Runtime_Event.LibraryItemAdded {
    get {
      if case .libraryItemAdded(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibraryItemAdded()
    }
    set {_uniqueStorage()._type = .libraryItemAdded(newValue)}
  }

  public var libraryItemRemoved: Stremio_Core_Runtime_Event.LibraryItemRemoved {
    get {
      if case .libraryItemRemoved(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibraryItemRemoved()
    }
    set {_uniqueStorage()._type = .libraryItemRemoved(newValue)}
  }

  public var libraryItemRewinded: Stremio_Core_Runtime_Event.LibraryItemRewinded {
    get {
      if case .libraryItemRewinded(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibraryItemRewinded()
    }
    set {_uniqueStorage()._type = .libraryItemRewinded(newValue)}
  }

  public var libraryItemNotificationsToggled: Stremio_Core_Runtime_Event.LibraryItemNotificationsToggled {
    get {
      if case .libraryItemNotificationsToggled(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibraryItemNotificationsToggled()
    }
    set {_uniqueStorage()._type = .libraryItemNotificationsToggled(newValue)}
  }

  public var libraryItemMarkedAsWatched: Stremio_Core_Runtime_Event.LibraryItemMarkedAsWatched {
    get {
      if case .libraryItemMarkedAsWatched(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.LibraryItemMarkedAsWatched()
    }
    set {_uniqueStorage()._type = .libraryItemMarkedAsWatched(newValue)}
  }

  public var notificationsDismissed: Stremio_Core_Runtime_Event.NotificationsDismissed {
    get {
      if case .notificationsDismissed(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.NotificationsDismissed()
    }
    set {_uniqueStorage()._type = .notificationsDismissed(newValue)}
  }

  public var playerPlaying: Stremio_Core_Runtime_Event.PlayerPlaying {
    get {
      if case .playerPlaying(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.PlayerPlaying()
    }
    set {_uniqueStorage()._type = .playerPlaying(newValue)}
  }

  public var playerStopped: Stremio_Core_Runtime_Event.PlayerStopped {
    get {
      if case .playerStopped(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.PlayerStopped()
    }
    set {_uniqueStorage()._type = .playerStopped(newValue)}
  }

  public var playerNextVideo: Stremio_Core_Runtime_Event.PlayerNextVideo {
    get {
      if case .playerNextVideo(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.PlayerNextVideo()
    }
    set {_uniqueStorage()._type = .playerNextVideo(newValue)}
  }

  public var playerEnded: Stremio_Core_Runtime_Event.PlayerEnded {
    get {
      if case .playerEnded(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.PlayerEnded()
    }
    set {_uniqueStorage()._type = .playerEnded(newValue)}
  }

  public var traktPlaying: Stremio_Core_Runtime_Event.TraktPlaying {
    get {
      if case .traktPlaying(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.TraktPlaying()
    }
    set {_uniqueStorage()._type = .traktPlaying(newValue)}
  }

  public var traktPaused: Stremio_Core_Runtime_Event.TraktPaused {
    get {
      if case .traktPaused(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.TraktPaused()
    }
    set {_uniqueStorage()._type = .traktPaused(newValue)}
  }

  public var magnetParsed: Stremio_Core_Runtime_Event.MagnetParsed {
    get {
      if case .magnetParsed(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.MagnetParsed()
    }
    set {_uniqueStorage()._type = .magnetParsed(newValue)}
  }

  public var torrentParsed: Stremio_Core_Runtime_Event.TorrentParsed {
    get {
      if case .torrentParsed(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.TorrentParsed()
    }
    set {_uniqueStorage()._type = .torrentParsed(newValue)}
  }

  public var playingOnDevice: Stremio_Core_Runtime_Event.PlayingOnDevice {
    get {
      if case .playingOnDevice(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.PlayingOnDevice()
    }
    set {_uniqueStorage()._type = .playingOnDevice(newValue)}
  }

  public var error: Stremio_Core_Runtime_Event.Error {
    get {
      if case .error(let v)? = _storage._type {return v}
      return Stremio_Core_Runtime_Event.Error()
    }
    set {_uniqueStorage()._type = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Type: Equatable {
    case profilePushedToStorage(Stremio_Core_Runtime_Event.ProfilePushedToStorage)
    case libraryItemsPushedToStorage(Stremio_Core_Runtime_Event.LibraryItemsPushedToStorage)
    case streamsPushedToStorage(Stremio_Core_Runtime_Event.StreamsPushedToStorage)
    case searchHistoryPushedToStorage(Stremio_Core_Runtime_Event.SearchHistoryPushedToStorage)
    case notificationsPushedToStorage(Stremio_Core_Runtime_Event.NotificationsPushedToStorage)
    case dismissedEventsPushedToStorage(Stremio_Core_Runtime_Event.DismissedEventsPushedToStorage)
    case userPulledFromApi(Stremio_Core_Runtime_Event.UserPulledFromAPI)
    case userPushedToApi(Stremio_Core_Runtime_Event.UserPushedToAPI)
    case addonsPulledFromApi(Stremio_Core_Runtime_Event.AddonsPulledFromAPI)
    case addonsPushedToApi(Stremio_Core_Runtime_Event.AddonsPushedToAPI)
    case librarySyncWithApiPlanned(Stremio_Core_Runtime_Event.LibrarySyncWithAPIPlanned)
    case libraryItemsPushedToApi(Stremio_Core_Runtime_Event.LibraryItemsPushedToAPI)
    case libraryItemsPulledFromApi(Stremio_Core_Runtime_Event.LibraryItemsPulledFromAPI)
    case userAuthenticated(Stremio_Core_Runtime_Event.UserAuthenticated)
    case userAddonsLocked(Stremio_Core_Runtime_Event.UserAddonsLocked)
    case userLibraryMissing(Stremio_Core_Runtime_Event.UserLibraryMissing)
    case userLoggedOut(Stremio_Core_Runtime_Event.UserLoggedOut)
    case sessionDeleted(Stremio_Core_Runtime_Event.SessionDeleted)
    case traktAddonFetched(Stremio_Core_Runtime_Event.TraktAddonFetched)
    case traktLoggedOut(Stremio_Core_Runtime_Event.TraktLoggedOut)
    case addonInstalled(Stremio_Core_Runtime_Event.AddonInstalled)
    case addonUpgraded(Stremio_Core_Runtime_Event.AddonUpgraded)
    case addonUninstalled(Stremio_Core_Runtime_Event.AddonUninstalled)
    case settingsUpdated(Stremio_Core_Runtime_Event.SettingsUpdated)
    case libraryItemAdded(Stremio_Core_Runtime_Event.LibraryItemAdded)
    case libraryItemRemoved(Stremio_Core_Runtime_Event.LibraryItemRemoved)
    case libraryItemRewinded(Stremio_Core_Runtime_Event.LibraryItemRewinded)
    case libraryItemNotificationsToggled(Stremio_Core_Runtime_Event.LibraryItemNotificationsToggled)
    case libraryItemMarkedAsWatched(Stremio_Core_Runtime_Event.LibraryItemMarkedAsWatched)
    case notificationsDismissed(Stremio_Core_Runtime_Event.NotificationsDismissed)
    case playerPlaying(Stremio_Core_Runtime_Event.PlayerPlaying)
    case playerStopped(Stremio_Core_Runtime_Event.PlayerStopped)
    case playerNextVideo(Stremio_Core_Runtime_Event.PlayerNextVideo)
    case playerEnded(Stremio_Core_Runtime_Event.PlayerEnded)
    case traktPlaying(Stremio_Core_Runtime_Event.TraktPlaying)
    case traktPaused(Stremio_Core_Runtime_Event.TraktPaused)
    case magnetParsed(Stremio_Core_Runtime_Event.MagnetParsed)
    case torrentParsed(Stremio_Core_Runtime_Event.TorrentParsed)
    case playingOnDevice(Stremio_Core_Runtime_Event.PlayingOnDevice)
    case error(Stremio_Core_Runtime_Event.Error)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .librarySyncWithApiPlanned: return {
        guard case .librarySyncWithApiPlanned(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .userAuthenticated: return {
        guard case .userAuthenticated(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .userAddonsLocked: return {
        guard case .userAddonsLocked(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .userLibraryMissing: return {
        guard case .userLibraryMissing(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .sessionDeleted: return {
        guard case .sessionDeleted(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .addonInstalled: return {
        guard case .addonInstalled(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .addonUpgraded: return {
        guard case .addonUpgraded(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .addonUninstalled: return {
        guard case .addonUninstalled(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .settingsUpdated: return {
        guard case .settingsUpdated(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .libraryItemAdded: return {
        guard case .libraryItemAdded(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .libraryItemRemoved: return {
        guard case .libraryItemRemoved(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .libraryItemRewinded: return {
        guard case .libraryItemRewinded(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .libraryItemNotificationsToggled: return {
        guard case .libraryItemNotificationsToggled(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .libraryItemMarkedAsWatched: return {
        guard case .libraryItemMarkedAsWatched(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .notificationsDismissed: return {
        guard case .notificationsDismissed(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .magnetParsed: return {
        guard case .magnetParsed(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .torrentParsed: return {
        guard case .torrentParsed(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .playingOnDevice: return {
        guard case .playingOnDevice(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .error: return {
        guard case .error(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: Stremio_Core_Runtime_Event.OneOf_Type, rhs: Stremio_Core_Runtime_Event.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.profilePushedToStorage, .profilePushedToStorage): return {
        guard case .profilePushedToStorage(let l) = lhs, case .profilePushedToStorage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryItemsPushedToStorage, .libraryItemsPushedToStorage): return {
        guard case .libraryItemsPushedToStorage(let l) = lhs, case .libraryItemsPushedToStorage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.streamsPushedToStorage, .streamsPushedToStorage): return {
        guard case .streamsPushedToStorage(let l) = lhs, case .streamsPushedToStorage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.searchHistoryPushedToStorage, .searchHistoryPushedToStorage): return {
        guard case .searchHistoryPushedToStorage(let l) = lhs, case .searchHistoryPushedToStorage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notificationsPushedToStorage, .notificationsPushedToStorage): return {
        guard case .notificationsPushedToStorage(let l) = lhs, case .notificationsPushedToStorage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dismissedEventsPushedToStorage, .dismissedEventsPushedToStorage): return {
        guard case .dismissedEventsPushedToStorage(let l) = lhs, case .dismissedEventsPushedToStorage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userPulledFromApi, .userPulledFromApi): return {
        guard case .userPulledFromApi(let l) = lhs, case .userPulledFromApi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userPushedToApi, .userPushedToApi): return {
        guard case .userPushedToApi(let l) = lhs, case .userPushedToApi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addonsPulledFromApi, .addonsPulledFromApi): return {
        guard case .addonsPulledFromApi(let l) = lhs, case .addonsPulledFromApi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addonsPushedToApi, .addonsPushedToApi): return {
        guard case .addonsPushedToApi(let l) = lhs, case .addonsPushedToApi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.librarySyncWithApiPlanned, .librarySyncWithApiPlanned): return {
        guard case .librarySyncWithApiPlanned(let l) = lhs, case .librarySyncWithApiPlanned(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryItemsPushedToApi, .libraryItemsPushedToApi): return {
        guard case .libraryItemsPushedToApi(let l) = lhs, case .libraryItemsPushedToApi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryItemsPulledFromApi, .libraryItemsPulledFromApi): return {
        guard case .libraryItemsPulledFromApi(let l) = lhs, case .libraryItemsPulledFromApi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userAuthenticated, .userAuthenticated): return {
        guard case .userAuthenticated(let l) = lhs, case .userAuthenticated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userAddonsLocked, .userAddonsLocked): return {
        guard case .userAddonsLocked(let l) = lhs, case .userAddonsLocked(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userLibraryMissing, .userLibraryMissing): return {
        guard case .userLibraryMissing(let l) = lhs, case .userLibraryMissing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userLoggedOut, .userLoggedOut): return {
        guard case .userLoggedOut(let l) = lhs, case .userLoggedOut(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionDeleted, .sessionDeleted): return {
        guard case .sessionDeleted(let l) = lhs, case .sessionDeleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.traktAddonFetched, .traktAddonFetched): return {
        guard case .traktAddonFetched(let l) = lhs, case .traktAddonFetched(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.traktLoggedOut, .traktLoggedOut): return {
        guard case .traktLoggedOut(let l) = lhs, case .traktLoggedOut(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addonInstalled, .addonInstalled): return {
        guard case .addonInstalled(let l) = lhs, case .addonInstalled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addonUpgraded, .addonUpgraded): return {
        guard case .addonUpgraded(let l) = lhs, case .addonUpgraded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addonUninstalled, .addonUninstalled): return {
        guard case .addonUninstalled(let l) = lhs, case .addonUninstalled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.settingsUpdated, .settingsUpdated): return {
        guard case .settingsUpdated(let l) = lhs, case .settingsUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryItemAdded, .libraryItemAdded): return {
        guard case .libraryItemAdded(let l) = lhs, case .libraryItemAdded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryItemRemoved, .libraryItemRemoved): return {
        guard case .libraryItemRemoved(let l) = lhs, case .libraryItemRemoved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryItemRewinded, .libraryItemRewinded): return {
        guard case .libraryItemRewinded(let l) = lhs, case .libraryItemRewinded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryItemNotificationsToggled, .libraryItemNotificationsToggled): return {
        guard case .libraryItemNotificationsToggled(let l) = lhs, case .libraryItemNotificationsToggled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryItemMarkedAsWatched, .libraryItemMarkedAsWatched): return {
        guard case .libraryItemMarkedAsWatched(let l) = lhs, case .libraryItemMarkedAsWatched(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notificationsDismissed, .notificationsDismissed): return {
        guard case .notificationsDismissed(let l) = lhs, case .notificationsDismissed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playerPlaying, .playerPlaying): return {
        guard case .playerPlaying(let l) = lhs, case .playerPlaying(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playerStopped, .playerStopped): return {
        guard case .playerStopped(let l) = lhs, case .playerStopped(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playerNextVideo, .playerNextVideo): return {
        guard case .playerNextVideo(let l) = lhs, case .playerNextVideo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playerEnded, .playerEnded): return {
        guard case .playerEnded(let l) = lhs, case .playerEnded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.traktPlaying, .traktPlaying): return {
        guard case .traktPlaying(let l) = lhs, case .traktPlaying(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.traktPaused, .traktPaused): return {
        guard case .traktPaused(let l) = lhs, case .traktPaused(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.magnetParsed, .magnetParsed): return {
        guard case .magnetParsed(let l) = lhs, case .magnetParsed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.torrentParsed, .torrentParsed): return {
        guard case .torrentParsed(let l) = lhs, case .torrentParsed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playingOnDevice, .playingOnDevice): return {
        guard case .playingOnDevice(let l) = lhs, case .playingOnDevice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct ProfilePushedToStorage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct LibraryItemsPushedToStorage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ids: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct StreamsPushedToStorage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct SearchHistoryPushedToStorage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct NotificationsPushedToStorage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ids: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct DismissedEventsPushedToStorage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct UserPulledFromAPI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct UserPushedToAPI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct AddonsPulledFromAPI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transportUrls: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct AddonsPushedToAPI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transportUrls: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct LibrarySyncWithAPIPlanned {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var plan: Stremio_Core_Runtime_PlanPair {
      get {return _plan ?? Stremio_Core_Runtime_PlanPair()}
      set {_plan = newValue}
    }
    /// Returns true if `plan` has been explicitly set.
    public var hasPlan: Bool {return self._plan != nil}
    /// Clears the value of `plan`. Subsequent reads from it will return its default value.
    public mutating func clearPlan() {self._plan = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
    fileprivate var _plan: Stremio_Core_Runtime_PlanPair? = nil
  }

  public struct LibraryItemsPushedToAPI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ids: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct LibraryItemsPulledFromAPI {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ids: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct UserAuthenticated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var authRequest: Stremio_Core_Types_AuthRequest {
      get {return _authRequest ?? Stremio_Core_Types_AuthRequest()}
      set {_authRequest = newValue}
    }
    /// Returns true if `authRequest` has been explicitly set.
    public var hasAuthRequest: Bool {return self._authRequest != nil}
    /// Clears the value of `authRequest`. Subsequent reads from it will return its default value.
    public mutating func clearAuthRequest() {self._authRequest = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _authRequest: Stremio_Core_Types_AuthRequest? = nil
  }

  public struct UserAddonsLocked {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var addonsLocked: Bool {
      get {return _addonsLocked ?? false}
      set {_addonsLocked = newValue}
    }
    /// Returns true if `addonsLocked` has been explicitly set.
    public var hasAddonsLocked: Bool {return self._addonsLocked != nil}
    /// Clears the value of `addonsLocked`. Subsequent reads from it will return its default value.
    public mutating func clearAddonsLocked() {self._addonsLocked = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _addonsLocked: Bool? = nil
  }

  public struct UserLibraryMissing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var libraryMissing: Bool {
      get {return _libraryMissing ?? false}
      set {_libraryMissing = newValue}
    }
    /// Returns true if `libraryMissing` has been explicitly set.
    public var hasLibraryMissing: Bool {return self._libraryMissing != nil}
    /// Clears the value of `libraryMissing`. Subsequent reads from it will return its default value.
    public mutating func clearLibraryMissing() {self._libraryMissing = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _libraryMissing: Bool? = nil
  }

  public struct UserLoggedOut {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct SessionDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var authKey: String {
      get {return _authKey ?? String()}
      set {_authKey = newValue}
    }
    /// Returns true if `authKey` has been explicitly set.
    public var hasAuthKey: Bool {return self._authKey != nil}
    /// Clears the value of `authKey`. Subsequent reads from it will return its default value.
    public mutating func clearAuthKey() {self._authKey = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _authKey: String? = nil
  }

  public struct TraktAddonFetched {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct TraktLoggedOut {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    public var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    public mutating func clearUid() {self._uid = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _uid: String? = nil
  }

  public struct AddonInstalled {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transportURL: String {
      get {return _transportURL ?? String()}
      set {_transportURL = newValue}
    }
    /// Returns true if `transportURL` has been explicitly set.
    public var hasTransportURL: Bool {return self._transportURL != nil}
    /// Clears the value of `transportURL`. Subsequent reads from it will return its default value.
    public mutating func clearTransportURL() {self._transportURL = nil}

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _transportURL: String? = nil
    fileprivate var _id: String? = nil
  }

  public struct AddonUpgraded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transportURL: String {
      get {return _transportURL ?? String()}
      set {_transportURL = newValue}
    }
    /// Returns true if `transportURL` has been explicitly set.
    public var hasTransportURL: Bool {return self._transportURL != nil}
    /// Clears the value of `transportURL`. Subsequent reads from it will return its default value.
    public mutating func clearTransportURL() {self._transportURL = nil}

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _transportURL: String? = nil
    fileprivate var _id: String? = nil
  }

  public struct AddonUninstalled {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var transportURL: String {
      get {return _transportURL ?? String()}
      set {_transportURL = newValue}
    }
    /// Returns true if `transportURL` has been explicitly set.
    public var hasTransportURL: Bool {return self._transportURL != nil}
    /// Clears the value of `transportURL`. Subsequent reads from it will return its default value.
    public mutating func clearTransportURL() {self._transportURL = nil}

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _transportURL: String? = nil
    fileprivate var _id: String? = nil
  }

  public struct SettingsUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var settings: Stremio_Core_Types_Profile.Settings {
      get {return _settings ?? Stremio_Core_Types_Profile.Settings()}
      set {_settings = newValue}
    }
    /// Returns true if `settings` has been explicitly set.
    public var hasSettings: Bool {return self._settings != nil}
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    public mutating func clearSettings() {self._settings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _settings: Stremio_Core_Types_Profile.Settings? = nil
  }

  public struct LibraryItemAdded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
  }

  public struct LibraryItemRemoved {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
  }

  public struct LibraryItemRewinded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
  }

  public struct LibraryItemNotificationsToggled {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
  }

  public struct LibraryItemMarkedAsWatched {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var isWatched: Bool {
      get {return _isWatched ?? false}
      set {_isWatched = newValue}
    }
    /// Returns true if `isWatched` has been explicitly set.
    public var hasIsWatched: Bool {return self._isWatched != nil}
    /// Clears the value of `isWatched`. Subsequent reads from it will return its default value.
    public mutating func clearIsWatched() {self._isWatched = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
    fileprivate var _isWatched: Bool? = nil
  }

  public struct NotificationsDismissed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
  }

  /// Empty
  public struct PlayerPlaying {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Empty
  public struct PlayerStopped {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Empty
  public struct PlayerNextVideo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Empty
  public struct PlayerEnded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Empty
  public struct TraktPlaying {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Empty
  public struct TraktPaused {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MagnetParsed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var magnet: String {
      get {return _magnet ?? String()}
      set {_magnet = newValue}
    }
    /// Returns true if `magnet` has been explicitly set.
    public var hasMagnet: Bool {return self._magnet != nil}
    /// Clears the value of `magnet`. Subsequent reads from it will return its default value.
    public mutating func clearMagnet() {self._magnet = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _magnet: String? = nil
  }

  public struct TorrentParsed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var torrent: Data {
      get {return _torrent ?? Data()}
      set {_torrent = newValue}
    }
    /// Returns true if `torrent` has been explicitly set.
    public var hasTorrent: Bool {return self._torrent != nil}
    /// Clears the value of `torrent`. Subsequent reads from it will return its default value.
    public mutating func clearTorrent() {self._torrent = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _torrent: Data? = nil
  }

  public struct PlayingOnDevice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var device: String {
      get {return _device ?? String()}
      set {_device = newValue}
    }
    /// Returns true if `device` has been explicitly set.
    public var hasDevice: Bool {return self._device != nil}
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    public mutating func clearDevice() {self._device = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _device: String? = nil
  }

  public struct Error {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var error: String {
      get {return _storage._error ?? String()}
      set {_uniqueStorage()._error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {return _storage._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {_uniqueStorage()._error = nil}

    public var source: Stremio_Core_Runtime_Event {
      get {return _storage._source ?? Stremio_Core_Runtime_Event()}
      set {_uniqueStorage()._source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    public var hasSource: Bool {return _storage._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    public mutating func clearSource() {_uniqueStorage()._source = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Stremio_Core_Runtime_PlanPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var first: [String] = []

  public var second: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stremio_Core_Runtime_Event: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.OneOf_Type: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.ProfilePushedToStorage: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibraryItemsPushedToStorage: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.StreamsPushedToStorage: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.SearchHistoryPushedToStorage: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.NotificationsPushedToStorage: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.DismissedEventsPushedToStorage: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.UserPulledFromAPI: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.UserPushedToAPI: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.AddonsPulledFromAPI: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.AddonsPushedToAPI: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibrarySyncWithAPIPlanned: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibraryItemsPushedToAPI: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibraryItemsPulledFromAPI: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.UserAuthenticated: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.UserAddonsLocked: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.UserLibraryMissing: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.UserLoggedOut: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.SessionDeleted: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.TraktAddonFetched: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.TraktLoggedOut: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.AddonInstalled: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.AddonUpgraded: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.AddonUninstalled: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.SettingsUpdated: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibraryItemAdded: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibraryItemRemoved: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibraryItemRewinded: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibraryItemNotificationsToggled: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.LibraryItemMarkedAsWatched: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.NotificationsDismissed: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.PlayerPlaying: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.PlayerStopped: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.PlayerNextVideo: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.PlayerEnded: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.TraktPlaying: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.TraktPaused: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.MagnetParsed: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.TorrentParsed: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.PlayingOnDevice: @unchecked Sendable {}
extension Stremio_Core_Runtime_Event.Error: @unchecked Sendable {}
extension Stremio_Core_Runtime_PlanPair: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stremio.core.runtime"

extension Stremio_Core_Runtime_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "profile_pushed_to_storage"),
    2: .standard(proto: "library_items_pushed_to_storage"),
    3: .standard(proto: "streams_pushed_to_storage"),
    4: .standard(proto: "search_history_pushed_to_storage"),
    5: .standard(proto: "notifications_pushed_to_storage"),
    6: .standard(proto: "dismissed_events_pushed_to_storage"),
    7: .standard(proto: "user_pulled_from_api"),
    8: .standard(proto: "user_pushed_to_api"),
    9: .standard(proto: "addons_pulled_from_api"),
    10: .standard(proto: "addons_pushed_to_api"),
    11: .standard(proto: "library_sync_with_api_planned"),
    12: .standard(proto: "library_items_pushed_to_api"),
    13: .standard(proto: "library_items_pulled_from_api"),
    14: .standard(proto: "user_authenticated"),
    15: .standard(proto: "user_addons_locked"),
    16: .standard(proto: "user_library_missing"),
    17: .standard(proto: "user_logged_out"),
    18: .standard(proto: "session_deleted"),
    19: .standard(proto: "trakt_addon_fetched"),
    20: .standard(proto: "trakt_logged_out"),
    21: .standard(proto: "addon_installed"),
    22: .standard(proto: "addon_upgraded"),
    23: .standard(proto: "addon_uninstalled"),
    24: .standard(proto: "settings_updated"),
    25: .standard(proto: "library_item_added"),
    26: .standard(proto: "library_item_removed"),
    27: .standard(proto: "library_item_rewinded"),
    28: .standard(proto: "library_item_notifications_toggled"),
    29: .standard(proto: "library_item_marked_as_watched"),
    30: .standard(proto: "notifications_dismissed"),
    31: .standard(proto: "player_playing"),
    32: .standard(proto: "player_stopped"),
    33: .standard(proto: "player_next_video"),
    34: .standard(proto: "player_ended"),
    35: .standard(proto: "trakt_playing"),
    36: .standard(proto: "trakt_paused"),
    37: .standard(proto: "magnet_parsed"),
    38: .standard(proto: "torrent_parsed"),
    39: .standard(proto: "playing_on_device"),
    100: .same(proto: "error"),
  ]

  fileprivate class _StorageClass {
    var _type: Stremio_Core_Runtime_Event.OneOf_Type?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._type, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Stremio_Core_Runtime_Event.ProfilePushedToStorage?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .profilePushedToStorage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .profilePushedToStorage(v)
          }
        }()
        case 2: try {
          var v: Stremio_Core_Runtime_Event.LibraryItemsPushedToStorage?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .libraryItemsPushedToStorage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .libraryItemsPushedToStorage(v)
          }
        }()
        case 3: try {
          var v: Stremio_Core_Runtime_Event.StreamsPushedToStorage?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .streamsPushedToStorage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .streamsPushedToStorage(v)
          }
        }()
        case 4: try {
          var v: Stremio_Core_Runtime_Event.SearchHistoryPushedToStorage?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .searchHistoryPushedToStorage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .searchHistoryPushedToStorage(v)
          }
        }()
        case 5: try {
          var v: Stremio_Core_Runtime_Event.NotificationsPushedToStorage?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .notificationsPushedToStorage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .notificationsPushedToStorage(v)
          }
        }()
        case 6: try {
          var v: Stremio_Core_Runtime_Event.DismissedEventsPushedToStorage?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .dismissedEventsPushedToStorage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .dismissedEventsPushedToStorage(v)
          }
        }()
        case 7: try {
          var v: Stremio_Core_Runtime_Event.UserPulledFromAPI?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .userPulledFromApi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .userPulledFromApi(v)
          }
        }()
        case 8: try {
          var v: Stremio_Core_Runtime_Event.UserPushedToAPI?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .userPushedToApi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .userPushedToApi(v)
          }
        }()
        case 9: try {
          var v: Stremio_Core_Runtime_Event.AddonsPulledFromAPI?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .addonsPulledFromApi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .addonsPulledFromApi(v)
          }
        }()
        case 10: try {
          var v: Stremio_Core_Runtime_Event.AddonsPushedToAPI?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .addonsPushedToApi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .addonsPushedToApi(v)
          }
        }()
        case 11: try {
          var v: Stremio_Core_Runtime_Event.LibrarySyncWithAPIPlanned?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .librarySyncWithApiPlanned(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .librarySyncWithApiPlanned(v)
          }
        }()
        case 12: try {
          var v: Stremio_Core_Runtime_Event.LibraryItemsPushedToAPI?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .libraryItemsPushedToApi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .libraryItemsPushedToApi(v)
          }
        }()
        case 13: try {
          var v: Stremio_Core_Runtime_Event.LibraryItemsPulledFromAPI?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .libraryItemsPulledFromApi(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .libraryItemsPulledFromApi(v)
          }
        }()
        case 14: try {
          var v: Stremio_Core_Runtime_Event.UserAuthenticated?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .userAuthenticated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .userAuthenticated(v)
          }
        }()
        case 15: try {
          var v: Stremio_Core_Runtime_Event.UserAddonsLocked?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .userAddonsLocked(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .userAddonsLocked(v)
          }
        }()
        case 16: try {
          var v: Stremio_Core_Runtime_Event.UserLibraryMissing?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .userLibraryMissing(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .userLibraryMissing(v)
          }
        }()
        case 17: try {
          var v: Stremio_Core_Runtime_Event.UserLoggedOut?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .userLoggedOut(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .userLoggedOut(v)
          }
        }()
        case 18: try {
          var v: Stremio_Core_Runtime_Event.SessionDeleted?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .sessionDeleted(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .sessionDeleted(v)
          }
        }()
        case 19: try {
          var v: Stremio_Core_Runtime_Event.TraktAddonFetched?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .traktAddonFetched(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .traktAddonFetched(v)
          }
        }()
        case 20: try {
          var v: Stremio_Core_Runtime_Event.TraktLoggedOut?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .traktLoggedOut(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .traktLoggedOut(v)
          }
        }()
        case 21: try {
          var v: Stremio_Core_Runtime_Event.AddonInstalled?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .addonInstalled(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .addonInstalled(v)
          }
        }()
        case 22: try {
          var v: Stremio_Core_Runtime_Event.AddonUpgraded?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .addonUpgraded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .addonUpgraded(v)
          }
        }()
        case 23: try {
          var v: Stremio_Core_Runtime_Event.AddonUninstalled?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .addonUninstalled(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .addonUninstalled(v)
          }
        }()
        case 24: try {
          var v: Stremio_Core_Runtime_Event.SettingsUpdated?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .settingsUpdated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .settingsUpdated(v)
          }
        }()
        case 25: try {
          var v: Stremio_Core_Runtime_Event.LibraryItemAdded?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .libraryItemAdded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .libraryItemAdded(v)
          }
        }()
        case 26: try {
          var v: Stremio_Core_Runtime_Event.LibraryItemRemoved?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .libraryItemRemoved(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .libraryItemRemoved(v)
          }
        }()
        case 27: try {
          var v: Stremio_Core_Runtime_Event.LibraryItemRewinded?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .libraryItemRewinded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .libraryItemRewinded(v)
          }
        }()
        case 28: try {
          var v: Stremio_Core_Runtime_Event.LibraryItemNotificationsToggled?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .libraryItemNotificationsToggled(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .libraryItemNotificationsToggled(v)
          }
        }()
        case 29: try {
          var v: Stremio_Core_Runtime_Event.LibraryItemMarkedAsWatched?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .libraryItemMarkedAsWatched(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .libraryItemMarkedAsWatched(v)
          }
        }()
        case 30: try {
          var v: Stremio_Core_Runtime_Event.NotificationsDismissed?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .notificationsDismissed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .notificationsDismissed(v)
          }
        }()
        case 31: try {
          var v: Stremio_Core_Runtime_Event.PlayerPlaying?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .playerPlaying(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .playerPlaying(v)
          }
        }()
        case 32: try {
          var v: Stremio_Core_Runtime_Event.PlayerStopped?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .playerStopped(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .playerStopped(v)
          }
        }()
        case 33: try {
          var v: Stremio_Core_Runtime_Event.PlayerNextVideo?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .playerNextVideo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .playerNextVideo(v)
          }
        }()
        case 34: try {
          var v: Stremio_Core_Runtime_Event.PlayerEnded?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .playerEnded(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .playerEnded(v)
          }
        }()
        case 35: try {
          var v: Stremio_Core_Runtime_Event.TraktPlaying?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .traktPlaying(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .traktPlaying(v)
          }
        }()
        case 36: try {
          var v: Stremio_Core_Runtime_Event.TraktPaused?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .traktPaused(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .traktPaused(v)
          }
        }()
        case 37: try {
          var v: Stremio_Core_Runtime_Event.MagnetParsed?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .magnetParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .magnetParsed(v)
          }
        }()
        case 38: try {
          var v: Stremio_Core_Runtime_Event.TorrentParsed?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .torrentParsed(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .torrentParsed(v)
          }
        }()
        case 39: try {
          var v: Stremio_Core_Runtime_Event.PlayingOnDevice?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .playingOnDevice(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .playingOnDevice(v)
          }
        }()
        case 100: try {
          var v: Stremio_Core_Runtime_Event.Error?
          var hadOneofValue = false
          if let current = _storage._type {
            hadOneofValue = true
            if case .error(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._type = .error(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._type {
      case .profilePushedToStorage?: try {
        guard case .profilePushedToStorage(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .libraryItemsPushedToStorage?: try {
        guard case .libraryItemsPushedToStorage(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .streamsPushedToStorage?: try {
        guard case .streamsPushedToStorage(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .searchHistoryPushedToStorage?: try {
        guard case .searchHistoryPushedToStorage(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .notificationsPushedToStorage?: try {
        guard case .notificationsPushedToStorage(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .dismissedEventsPushedToStorage?: try {
        guard case .dismissedEventsPushedToStorage(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .userPulledFromApi?: try {
        guard case .userPulledFromApi(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .userPushedToApi?: try {
        guard case .userPushedToApi(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .addonsPulledFromApi?: try {
        guard case .addonsPulledFromApi(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .addonsPushedToApi?: try {
        guard case .addonsPushedToApi(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .librarySyncWithApiPlanned?: try {
        guard case .librarySyncWithApiPlanned(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .libraryItemsPushedToApi?: try {
        guard case .libraryItemsPushedToApi(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .libraryItemsPulledFromApi?: try {
        guard case .libraryItemsPulledFromApi(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .userAuthenticated?: try {
        guard case .userAuthenticated(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .userAddonsLocked?: try {
        guard case .userAddonsLocked(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .userLibraryMissing?: try {
        guard case .userLibraryMissing(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .userLoggedOut?: try {
        guard case .userLoggedOut(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .sessionDeleted?: try {
        guard case .sessionDeleted(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .traktAddonFetched?: try {
        guard case .traktAddonFetched(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .traktLoggedOut?: try {
        guard case .traktLoggedOut(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .addonInstalled?: try {
        guard case .addonInstalled(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .addonUpgraded?: try {
        guard case .addonUpgraded(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .addonUninstalled?: try {
        guard case .addonUninstalled(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .settingsUpdated?: try {
        guard case .settingsUpdated(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .libraryItemAdded?: try {
        guard case .libraryItemAdded(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .libraryItemRemoved?: try {
        guard case .libraryItemRemoved(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .libraryItemRewinded?: try {
        guard case .libraryItemRewinded(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .libraryItemNotificationsToggled?: try {
        guard case .libraryItemNotificationsToggled(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .libraryItemMarkedAsWatched?: try {
        guard case .libraryItemMarkedAsWatched(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .notificationsDismissed?: try {
        guard case .notificationsDismissed(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .playerPlaying?: try {
        guard case .playerPlaying(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .playerStopped?: try {
        guard case .playerStopped(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .playerNextVideo?: try {
        guard case .playerNextVideo(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .playerEnded?: try {
        guard case .playerEnded(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .traktPlaying?: try {
        guard case .traktPlaying(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .traktPaused?: try {
        guard case .traktPaused(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .magnetParsed?: try {
        guard case .magnetParsed(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .torrentParsed?: try {
        guard case .torrentParsed(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .playingOnDevice?: try {
        guard case .playingOnDevice(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .error?: try {
        guard case .error(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event, rhs: Stremio_Core_Runtime_Event) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.ProfilePushedToStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".ProfilePushedToStorage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.ProfilePushedToStorage, rhs: Stremio_Core_Runtime_Event.ProfilePushedToStorage) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibraryItemsPushedToStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibraryItemsPushedToStorage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibraryItemsPushedToStorage, rhs: Stremio_Core_Runtime_Event.LibraryItemsPushedToStorage) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.StreamsPushedToStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".StreamsPushedToStorage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.StreamsPushedToStorage, rhs: Stremio_Core_Runtime_Event.StreamsPushedToStorage) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.SearchHistoryPushedToStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".SearchHistoryPushedToStorage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.SearchHistoryPushedToStorage, rhs: Stremio_Core_Runtime_Event.SearchHistoryPushedToStorage) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.NotificationsPushedToStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".NotificationsPushedToStorage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.NotificationsPushedToStorage, rhs: Stremio_Core_Runtime_Event.NotificationsPushedToStorage) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.DismissedEventsPushedToStorage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".DismissedEventsPushedToStorage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.DismissedEventsPushedToStorage, rhs: Stremio_Core_Runtime_Event.DismissedEventsPushedToStorage) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.UserPulledFromAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".UserPulledFromAPI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.UserPulledFromAPI, rhs: Stremio_Core_Runtime_Event.UserPulledFromAPI) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.UserPushedToAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".UserPushedToAPI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.UserPushedToAPI, rhs: Stremio_Core_Runtime_Event.UserPushedToAPI) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.AddonsPulledFromAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".AddonsPulledFromAPI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transport_urls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.transportUrls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transportUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transportUrls, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.AddonsPulledFromAPI, rhs: Stremio_Core_Runtime_Event.AddonsPulledFromAPI) -> Bool {
    if lhs.transportUrls != rhs.transportUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.AddonsPushedToAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".AddonsPushedToAPI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transport_urls"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.transportUrls) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transportUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transportUrls, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.AddonsPushedToAPI, rhs: Stremio_Core_Runtime_Event.AddonsPushedToAPI) -> Bool {
    if lhs.transportUrls != rhs.transportUrls {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibrarySyncWithAPIPlanned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibrarySyncWithAPIPlanned"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
    2: .same(proto: "plan"),
  ]

  public var isInitialized: Bool {
    if self._plan == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._plan) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._plan {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibrarySyncWithAPIPlanned, rhs: Stremio_Core_Runtime_Event.LibrarySyncWithAPIPlanned) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs._plan != rhs._plan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibraryItemsPushedToAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibraryItemsPushedToAPI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibraryItemsPushedToAPI, rhs: Stremio_Core_Runtime_Event.LibraryItemsPushedToAPI) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibraryItemsPulledFromAPI: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibraryItemsPulledFromAPI"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibraryItemsPulledFromAPI, rhs: Stremio_Core_Runtime_Event.LibraryItemsPulledFromAPI) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.UserAuthenticated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".UserAuthenticated"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_request"),
  ]

  public var isInitialized: Bool {
    if self._authRequest == nil {return false}
    if let v = self._authRequest, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authRequest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.UserAuthenticated, rhs: Stremio_Core_Runtime_Event.UserAuthenticated) -> Bool {
    if lhs._authRequest != rhs._authRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.UserAddonsLocked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".UserAddonsLocked"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "addons_locked"),
  ]

  public var isInitialized: Bool {
    if self._addonsLocked == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._addonsLocked) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._addonsLocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.UserAddonsLocked, rhs: Stremio_Core_Runtime_Event.UserAddonsLocked) -> Bool {
    if lhs._addonsLocked != rhs._addonsLocked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.UserLibraryMissing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".UserLibraryMissing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "library_missing"),
  ]

  public var isInitialized: Bool {
    if self._libraryMissing == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._libraryMissing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._libraryMissing {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.UserLibraryMissing, rhs: Stremio_Core_Runtime_Event.UserLibraryMissing) -> Bool {
    if lhs._libraryMissing != rhs._libraryMissing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.UserLoggedOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".UserLoggedOut"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.UserLoggedOut, rhs: Stremio_Core_Runtime_Event.UserLoggedOut) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.SessionDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".SessionDeleted"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_key"),
  ]

  public var isInitialized: Bool {
    if self._authKey == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._authKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authKey {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.SessionDeleted, rhs: Stremio_Core_Runtime_Event.SessionDeleted) -> Bool {
    if lhs._authKey != rhs._authKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.TraktAddonFetched: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".TraktAddonFetched"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.TraktAddonFetched, rhs: Stremio_Core_Runtime_Event.TraktAddonFetched) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.TraktLoggedOut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".TraktLoggedOut"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uid"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.TraktLoggedOut, rhs: Stremio_Core_Runtime_Event.TraktLoggedOut) -> Bool {
    if lhs._uid != rhs._uid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.AddonInstalled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".AddonInstalled"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transport_url"),
    2: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._transportURL == nil {return false}
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._transportURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transportURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.AddonInstalled, rhs: Stremio_Core_Runtime_Event.AddonInstalled) -> Bool {
    if lhs._transportURL != rhs._transportURL {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.AddonUpgraded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".AddonUpgraded"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transport_url"),
    2: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._transportURL == nil {return false}
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._transportURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transportURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.AddonUpgraded, rhs: Stremio_Core_Runtime_Event.AddonUpgraded) -> Bool {
    if lhs._transportURL != rhs._transportURL {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.AddonUninstalled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".AddonUninstalled"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transport_url"),
    2: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._transportURL == nil {return false}
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._transportURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._transportURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.AddonUninstalled, rhs: Stremio_Core_Runtime_Event.AddonUninstalled) -> Bool {
    if lhs._transportURL != rhs._transportURL {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.SettingsUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".SettingsUpdated"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
  ]

  public var isInitialized: Bool {
    if self._settings == nil {return false}
    if let v = self._settings, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.SettingsUpdated, rhs: Stremio_Core_Runtime_Event.SettingsUpdated) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibraryItemAdded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibraryItemAdded"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibraryItemAdded, rhs: Stremio_Core_Runtime_Event.LibraryItemAdded) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibraryItemRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibraryItemRemoved"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibraryItemRemoved, rhs: Stremio_Core_Runtime_Event.LibraryItemRemoved) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibraryItemRewinded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibraryItemRewinded"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibraryItemRewinded, rhs: Stremio_Core_Runtime_Event.LibraryItemRewinded) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibraryItemNotificationsToggled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibraryItemNotificationsToggled"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibraryItemNotificationsToggled, rhs: Stremio_Core_Runtime_Event.LibraryItemNotificationsToggled) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.LibraryItemMarkedAsWatched: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".LibraryItemMarkedAsWatched"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "is_watched"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._isWatched == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isWatched) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isWatched {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.LibraryItemMarkedAsWatched, rhs: Stremio_Core_Runtime_Event.LibraryItemMarkedAsWatched) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._isWatched != rhs._isWatched {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.NotificationsDismissed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".NotificationsDismissed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.NotificationsDismissed, rhs: Stremio_Core_Runtime_Event.NotificationsDismissed) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.PlayerPlaying: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".PlayerPlaying"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.PlayerPlaying, rhs: Stremio_Core_Runtime_Event.PlayerPlaying) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.PlayerStopped: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".PlayerStopped"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.PlayerStopped, rhs: Stremio_Core_Runtime_Event.PlayerStopped) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.PlayerNextVideo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".PlayerNextVideo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.PlayerNextVideo, rhs: Stremio_Core_Runtime_Event.PlayerNextVideo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.PlayerEnded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".PlayerEnded"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.PlayerEnded, rhs: Stremio_Core_Runtime_Event.PlayerEnded) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.TraktPlaying: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".TraktPlaying"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.TraktPlaying, rhs: Stremio_Core_Runtime_Event.TraktPlaying) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.TraktPaused: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".TraktPaused"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.TraktPaused, rhs: Stremio_Core_Runtime_Event.TraktPaused) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.MagnetParsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".MagnetParsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "magnet"),
  ]

  public var isInitialized: Bool {
    if self._magnet == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._magnet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._magnet {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.MagnetParsed, rhs: Stremio_Core_Runtime_Event.MagnetParsed) -> Bool {
    if lhs._magnet != rhs._magnet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.TorrentParsed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".TorrentParsed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "torrent"),
  ]

  public var isInitialized: Bool {
    if self._torrent == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._torrent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._torrent {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.TorrentParsed, rhs: Stremio_Core_Runtime_Event.TorrentParsed) -> Bool {
    if lhs._torrent != rhs._torrent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.PlayingOnDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".PlayingOnDevice"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
  ]

  public var isInitialized: Bool {
    if self._device == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.PlayingOnDevice, rhs: Stremio_Core_Runtime_Event.PlayingOnDevice) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_Event.Error: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Runtime_Event.protoMessageName + ".Error"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "source"),
  ]

  fileprivate class _StorageClass {
    var _error: String? = nil
    var _source: Stremio_Core_Runtime_Event? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _error = source._error
      _source = source._source
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._error == nil {return false}
      if _storage._source == nil {return false}
      if let v = _storage._source, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._error) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._source) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._error {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_Event.Error, rhs: Stremio_Core_Runtime_Event.Error) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._error != rhs_storage._error {return false}
        if _storage._source != rhs_storage._source {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Runtime_PlanPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PlanPair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "first"),
    2: .same(proto: "second"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.first) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.second) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.first.isEmpty {
      try visitor.visitRepeatedStringField(value: self.first, fieldNumber: 1)
    }
    if !self.second.isEmpty {
      try visitor.visitRepeatedStringField(value: self.second, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_PlanPair, rhs: Stremio_Core_Runtime_PlanPair) -> Bool {
    if lhs.first != rhs.first {return false}
    if lhs.second != rhs.second {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
