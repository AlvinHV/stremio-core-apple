// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stremio/core/runtime/action_load.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Stremio_Core_Runtime_ActionLoad {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var args: Stremio_Core_Runtime_ActionLoad.OneOf_Args? = nil

  public var addonDetails: Stremio_Core_Models_AddonDetails.Selected {
    get {
      if case .addonDetails(let v)? = args {return v}
      return Stremio_Core_Models_AddonDetails.Selected()
    }
    set {args = .addonDetails(newValue)}
  }

  public var catalogsWithExtra: Stremio_Core_Models_CatalogsWithExtra.Selected {
    get {
      if case .catalogsWithExtra(let v)? = args {return v}
      return Stremio_Core_Models_CatalogsWithExtra.Selected()
    }
    set {args = .catalogsWithExtra(newValue)}
  }

  public var catalogWithFilters: Stremio_Core_Models_CatalogWithFilters.Selected {
    get {
      if case .catalogWithFilters(let v)? = args {return v}
      return Stremio_Core_Models_CatalogWithFilters.Selected()
    }
    set {args = .catalogWithFilters(newValue)}
  }

  public var addonsWithFilters: Stremio_Core_Models_AddonsWithFilters.Selected {
    get {
      if case .addonsWithFilters(let v)? = args {return v}
      return Stremio_Core_Models_AddonsWithFilters.Selected()
    }
    set {args = .addonsWithFilters(newValue)}
  }

  public var libraryByType: Stremio_Core_Models_LibraryByType.Selected {
    get {
      if case .libraryByType(let v)? = args {return v}
      return Stremio_Core_Models_LibraryByType.Selected()
    }
    set {args = .libraryByType(newValue)}
  }

  public var libraryWithFilters: Stremio_Core_Models_LibraryWithFilters.Selected {
    get {
      if case .libraryWithFilters(let v)? = args {return v}
      return Stremio_Core_Models_LibraryWithFilters.Selected()
    }
    set {args = .libraryWithFilters(newValue)}
  }

  public var metaDetails: Stremio_Core_Models_MetaDetails.Selected {
    get {
      if case .metaDetails(let v)? = args {return v}
      return Stremio_Core_Models_MetaDetails.Selected()
    }
    set {args = .metaDetails(newValue)}
  }

  public var player: Stremio_Core_Models_Player.Selected {
    get {
      if case .player(let v)? = args {return v}
      return Stremio_Core_Models_Player.Selected()
    }
    set {args = .player(newValue)}
  }

  public var link: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .link(let v)? = args {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {args = .link(newValue)}
  }

  public var dataExport: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .dataExport(let v)? = args {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {args = .dataExport(newValue)}
  }

  public var localSearch: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .localSearch(let v)? = args {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {args = .localSearch(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Args: Equatable {
    case addonDetails(Stremio_Core_Models_AddonDetails.Selected)
    case catalogsWithExtra(Stremio_Core_Models_CatalogsWithExtra.Selected)
    case catalogWithFilters(Stremio_Core_Models_CatalogWithFilters.Selected)
    case addonsWithFilters(Stremio_Core_Models_AddonsWithFilters.Selected)
    case libraryByType(Stremio_Core_Models_LibraryByType.Selected)
    case libraryWithFilters(Stremio_Core_Models_LibraryWithFilters.Selected)
    case metaDetails(Stremio_Core_Models_MetaDetails.Selected)
    case player(Stremio_Core_Models_Player.Selected)
    case link(SwiftProtobuf.Google_Protobuf_Empty)
    case dataExport(SwiftProtobuf.Google_Protobuf_Empty)
    case localSearch(SwiftProtobuf.Google_Protobuf_Empty)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .addonDetails: return {
        guard case .addonDetails(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .catalogsWithExtra: return {
        guard case .catalogsWithExtra(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .catalogWithFilters: return {
        guard case .catalogWithFilters(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .addonsWithFilters: return {
        guard case .addonsWithFilters(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .libraryByType: return {
        guard case .libraryByType(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .libraryWithFilters: return {
        guard case .libraryWithFilters(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .metaDetails: return {
        guard case .metaDetails(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .player: return {
        guard case .player(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: Stremio_Core_Runtime_ActionLoad.OneOf_Args, rhs: Stremio_Core_Runtime_ActionLoad.OneOf_Args) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.addonDetails, .addonDetails): return {
        guard case .addonDetails(let l) = lhs, case .addonDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.catalogsWithExtra, .catalogsWithExtra): return {
        guard case .catalogsWithExtra(let l) = lhs, case .catalogsWithExtra(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.catalogWithFilters, .catalogWithFilters): return {
        guard case .catalogWithFilters(let l) = lhs, case .catalogWithFilters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addonsWithFilters, .addonsWithFilters): return {
        guard case .addonsWithFilters(let l) = lhs, case .addonsWithFilters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryByType, .libraryByType): return {
        guard case .libraryByType(let l) = lhs, case .libraryByType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.libraryWithFilters, .libraryWithFilters): return {
        guard case .libraryWithFilters(let l) = lhs, case .libraryWithFilters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metaDetails, .metaDetails): return {
        guard case .metaDetails(let l) = lhs, case .metaDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.player, .player): return {
        guard case .player(let l) = lhs, case .player(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.link, .link): return {
        guard case .link(let l) = lhs, case .link(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dataExport, .dataExport): return {
        guard case .dataExport(let l) = lhs, case .dataExport(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localSearch, .localSearch): return {
        guard case .localSearch(let l) = lhs, case .localSearch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stremio_Core_Runtime_ActionLoad: @unchecked Sendable {}
extension Stremio_Core_Runtime_ActionLoad.OneOf_Args: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stremio.core.runtime"

extension Stremio_Core_Runtime_ActionLoad: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionLoad"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "addon_details"),
    2: .standard(proto: "catalogs_with_extra"),
    3: .standard(proto: "catalog_with_filters"),
    4: .standard(proto: "addons_with_filters"),
    5: .standard(proto: "library_by_type"),
    6: .standard(proto: "library_with_filters"),
    7: .standard(proto: "meta_details"),
    8: .same(proto: "player"),
    9: .same(proto: "link"),
    10: .standard(proto: "data_export"),
    11: .standard(proto: "local_search"),
  ]

  public var isInitialized: Bool {
    if let v = self.args, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stremio_Core_Models_AddonDetails.Selected?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .addonDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .addonDetails(v)
        }
      }()
      case 2: try {
        var v: Stremio_Core_Models_CatalogsWithExtra.Selected?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .catalogsWithExtra(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .catalogsWithExtra(v)
        }
      }()
      case 3: try {
        var v: Stremio_Core_Models_CatalogWithFilters.Selected?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .catalogWithFilters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .catalogWithFilters(v)
        }
      }()
      case 4: try {
        var v: Stremio_Core_Models_AddonsWithFilters.Selected?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .addonsWithFilters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .addonsWithFilters(v)
        }
      }()
      case 5: try {
        var v: Stremio_Core_Models_LibraryByType.Selected?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .libraryByType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .libraryByType(v)
        }
      }()
      case 6: try {
        var v: Stremio_Core_Models_LibraryWithFilters.Selected?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .libraryWithFilters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .libraryWithFilters(v)
        }
      }()
      case 7: try {
        var v: Stremio_Core_Models_MetaDetails.Selected?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .metaDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .metaDetails(v)
        }
      }()
      case 8: try {
        var v: Stremio_Core_Models_Player.Selected?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .player(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .player(v)
        }
      }()
      case 9: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .link(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .link(v)
        }
      }()
      case 10: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .dataExport(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .dataExport(v)
        }
      }()
      case 11: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.args {
          hadOneofValue = true
          if case .localSearch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.args = .localSearch(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.args {
    case .addonDetails?: try {
      guard case .addonDetails(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .catalogsWithExtra?: try {
      guard case .catalogsWithExtra(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .catalogWithFilters?: try {
      guard case .catalogWithFilters(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .addonsWithFilters?: try {
      guard case .addonsWithFilters(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .libraryByType?: try {
      guard case .libraryByType(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .libraryWithFilters?: try {
      guard case .libraryWithFilters(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .metaDetails?: try {
      guard case .metaDetails(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .player?: try {
      guard case .player(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .link?: try {
      guard case .link(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .dataExport?: try {
      guard case .dataExport(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .localSearch?: try {
      guard case .localSearch(let v)? = self.args else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Runtime_ActionLoad, rhs: Stremio_Core_Runtime_ActionLoad) -> Bool {
    if lhs.args != rhs.args {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
