// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stremio/core/types/manifest.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Stremio_Core_Types_Descriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var manifest: Stremio_Core_Types_Manifest {
    get {return _storage._manifest ?? Stremio_Core_Types_Manifest()}
    set {_uniqueStorage()._manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  public var hasManifest: Bool {return _storage._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  public mutating func clearManifest() {_uniqueStorage()._manifest = nil}

  public var transportURL: String {
    get {return _storage._transportURL ?? String()}
    set {_uniqueStorage()._transportURL = newValue}
  }
  /// Returns true if `transportURL` has been explicitly set.
  public var hasTransportURL: Bool {return _storage._transportURL != nil}
  /// Clears the value of `transportURL`. Subsequent reads from it will return its default value.
  public mutating func clearTransportURL() {_uniqueStorage()._transportURL = nil}

  public var flags: Stremio_Core_Types_DescriptorFlags {
    get {return _storage._flags ?? Stremio_Core_Types_DescriptorFlags()}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  public var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  public mutating func clearFlags() {_uniqueStorage()._flags = nil}

  public var installed: Bool {
    get {return _storage._installed ?? false}
    set {_uniqueStorage()._installed = newValue}
  }
  /// Returns true if `installed` has been explicitly set.
  public var hasInstalled: Bool {return _storage._installed != nil}
  /// Clears the value of `installed`. Subsequent reads from it will return its default value.
  public mutating func clearInstalled() {_uniqueStorage()._installed = nil}

  public var installable: Bool {
    get {return _storage._installable ?? false}
    set {_uniqueStorage()._installable = newValue}
  }
  /// Returns true if `installable` has been explicitly set.
  public var hasInstallable: Bool {return _storage._installable != nil}
  /// Clears the value of `installable`. Subsequent reads from it will return its default value.
  public mutating func clearInstallable() {_uniqueStorage()._installable = nil}

  public var upgradeable: Bool {
    get {return _storage._upgradeable ?? false}
    set {_uniqueStorage()._upgradeable = newValue}
  }
  /// Returns true if `upgradeable` has been explicitly set.
  public var hasUpgradeable: Bool {return _storage._upgradeable != nil}
  /// Clears the value of `upgradeable`. Subsequent reads from it will return its default value.
  public mutating func clearUpgradeable() {_uniqueStorage()._upgradeable = nil}

  public var uninstallable: Bool {
    get {return _storage._uninstallable ?? false}
    set {_uniqueStorage()._uninstallable = newValue}
  }
  /// Returns true if `uninstallable` has been explicitly set.
  public var hasUninstallable: Bool {return _storage._uninstallable != nil}
  /// Clears the value of `uninstallable`. Subsequent reads from it will return its default value.
  public mutating func clearUninstallable() {_uniqueStorage()._uninstallable = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Stremio_Core_Types_DescriptorPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var manifest: Stremio_Core_Types_ManifestPreview {
    get {return _manifest ?? Stremio_Core_Types_ManifestPreview()}
    set {_manifest = newValue}
  }
  /// Returns true if `manifest` has been explicitly set.
  public var hasManifest: Bool {return self._manifest != nil}
  /// Clears the value of `manifest`. Subsequent reads from it will return its default value.
  public mutating func clearManifest() {self._manifest = nil}

  public var transportURL: String {
    get {return _transportURL ?? String()}
    set {_transportURL = newValue}
  }
  /// Returns true if `transportURL` has been explicitly set.
  public var hasTransportURL: Bool {return self._transportURL != nil}
  /// Clears the value of `transportURL`. Subsequent reads from it will return its default value.
  public mutating func clearTransportURL() {self._transportURL = nil}

  public var installed: Bool {
    get {return _installed ?? false}
    set {_installed = newValue}
  }
  /// Returns true if `installed` has been explicitly set.
  public var hasInstalled: Bool {return self._installed != nil}
  /// Clears the value of `installed`. Subsequent reads from it will return its default value.
  public mutating func clearInstalled() {self._installed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _manifest: Stremio_Core_Types_ManifestPreview? = nil
  fileprivate var _transportURL: String? = nil
  fileprivate var _installed: Bool? = nil
}

public struct Stremio_Core_Types_DescriptorFlags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var official: Bool {
    get {return _official ?? false}
    set {_official = newValue}
  }
  /// Returns true if `official` has been explicitly set.
  public var hasOfficial: Bool {return self._official != nil}
  /// Clears the value of `official`. Subsequent reads from it will return its default value.
  public mutating func clearOfficial() {self._official = nil}

  public var protected: Bool {
    get {return _protected ?? false}
    set {_protected = newValue}
  }
  /// Returns true if `protected` has been explicitly set.
  public var hasProtected: Bool {return self._protected != nil}
  /// Clears the value of `protected`. Subsequent reads from it will return its default value.
  public mutating func clearProtected() {self._protected = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _official: Bool? = nil
  fileprivate var _protected: Bool? = nil
}

public struct Stremio_Core_Types_Manifest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  public var logo: String {
    get {return _logo ?? String()}
    set {_logo = newValue}
  }
  /// Returns true if `logo` has been explicitly set.
  public var hasLogo: Bool {return self._logo != nil}
  /// Clears the value of `logo`. Subsequent reads from it will return its default value.
  public mutating func clearLogo() {self._logo = nil}

  public var background: String {
    get {return _background ?? String()}
    set {_background = newValue}
  }
  /// Returns true if `background` has been explicitly set.
  public var hasBackground: Bool {return self._background != nil}
  /// Clears the value of `background`. Subsequent reads from it will return its default value.
  public mutating func clearBackground() {self._background = nil}

  public var types: [String] = []

  public var contactEmail: String {
    get {return _contactEmail ?? String()}
    set {_contactEmail = newValue}
  }
  /// Returns true if `contactEmail` has been explicitly set.
  public var hasContactEmail: Bool {return self._contactEmail != nil}
  /// Clears the value of `contactEmail`. Subsequent reads from it will return its default value.
  public mutating func clearContactEmail() {self._contactEmail = nil}

  public var resources: [Stremio_Core_Types_ManifestResource] = []

  public var idPrefixes: [String] = []

  public var catalogs: [Stremio_Core_Types_ManifestCatalog] = []

  public var addonCatalogs: [Stremio_Core_Types_ManifestCatalog] = []

  public var behaviorHints: Stremio_Core_Types_ManifestBehaviorHints {
    get {return _behaviorHints ?? Stremio_Core_Types_ManifestBehaviorHints()}
    set {_behaviorHints = newValue}
  }
  /// Returns true if `behaviorHints` has been explicitly set.
  public var hasBehaviorHints: Bool {return self._behaviorHints != nil}
  /// Clears the value of `behaviorHints`. Subsequent reads from it will return its default value.
  public mutating func clearBehaviorHints() {self._behaviorHints = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _version: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _logo: String? = nil
  fileprivate var _background: String? = nil
  fileprivate var _contactEmail: String? = nil
  fileprivate var _behaviorHints: Stremio_Core_Types_ManifestBehaviorHints? = nil
}

public struct Stremio_Core_Types_ManifestPreview {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  public var logo: String {
    get {return _logo ?? String()}
    set {_logo = newValue}
  }
  /// Returns true if `logo` has been explicitly set.
  public var hasLogo: Bool {return self._logo != nil}
  /// Clears the value of `logo`. Subsequent reads from it will return its default value.
  public mutating func clearLogo() {self._logo = nil}

  public var background: String {
    get {return _background ?? String()}
    set {_background = newValue}
  }
  /// Returns true if `background` has been explicitly set.
  public var hasBackground: Bool {return self._background != nil}
  /// Clears the value of `background`. Subsequent reads from it will return its default value.
  public mutating func clearBackground() {self._background = nil}

  public var types: [String] = []

  public var behaviorHints: Stremio_Core_Types_ManifestBehaviorHints {
    get {return _behaviorHints ?? Stremio_Core_Types_ManifestBehaviorHints()}
    set {_behaviorHints = newValue}
  }
  /// Returns true if `behaviorHints` has been explicitly set.
  public var hasBehaviorHints: Bool {return self._behaviorHints != nil}
  /// Clears the value of `behaviorHints`. Subsequent reads from it will return its default value.
  public mutating func clearBehaviorHints() {self._behaviorHints = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _version: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _description_p: String? = nil
  fileprivate var _logo: String? = nil
  fileprivate var _background: String? = nil
  fileprivate var _behaviorHints: Stremio_Core_Types_ManifestBehaviorHints? = nil
}

public struct Stremio_Core_Types_ManifestResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var types: [String] = []

  public var idPrefixes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
}

public struct Stremio_Core_Types_ManifestCatalog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var type: String {
    get {return _type ?? String()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var extra: Stremio_Core_Types_ManifestExtra {
    get {return _extra ?? Stremio_Core_Types_ManifestExtra()}
    set {_extra = newValue}
  }
  /// Returns true if `extra` has been explicitly set.
  public var hasExtra: Bool {return self._extra != nil}
  /// Clears the value of `extra`. Subsequent reads from it will return its default value.
  public mutating func clearExtra() {self._extra = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: String? = nil
  fileprivate var _type: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _extra: Stremio_Core_Types_ManifestExtra? = nil
}

public struct Stremio_Core_Types_ManifestExtra {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var extra: Stremio_Core_Types_ManifestExtra.OneOf_Extra? = nil

  public var full: Stremio_Core_Types_FullManifestExtra {
    get {
      if case .full(let v)? = extra {return v}
      return Stremio_Core_Types_FullManifestExtra()
    }
    set {extra = .full(newValue)}
  }

  public var short: Stremio_Core_Types_ShortManifestExtra {
    get {
      if case .short(let v)? = extra {return v}
      return Stremio_Core_Types_ShortManifestExtra()
    }
    set {extra = .short(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Extra: Equatable {
    case full(Stremio_Core_Types_FullManifestExtra)
    case short(Stremio_Core_Types_ShortManifestExtra)

    fileprivate var isInitialized: Bool {
      guard case .full(let v) = self else {return true}
      return v.isInitialized
    }

  #if !swift(>=4.1)
    public static func ==(lhs: Stremio_Core_Types_ManifestExtra.OneOf_Extra, rhs: Stremio_Core_Types_ManifestExtra.OneOf_Extra) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.full, .full): return {
        guard case .full(let l) = lhs, case .full(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.short, .short): return {
        guard case .short(let l) = lhs, case .short(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Stremio_Core_Types_ShortManifestExtra {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var required: [String] = []

  public var supported: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Stremio_Core_Types_FullManifestExtra {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var props: [Stremio_Core_Types_ExtraProp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Stremio_Core_Types_ExtraProp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  public var isRequired: Bool {
    get {return _isRequired ?? false}
    set {_isRequired = newValue}
  }
  /// Returns true if `isRequired` has been explicitly set.
  public var hasIsRequired: Bool {return self._isRequired != nil}
  /// Clears the value of `isRequired`. Subsequent reads from it will return its default value.
  public mutating func clearIsRequired() {self._isRequired = nil}

  public var options: [String] = []

  public var optionsLimit: Int32 {
    get {return _optionsLimit ?? 0}
    set {_optionsLimit = newValue}
  }
  /// Returns true if `optionsLimit` has been explicitly set.
  public var hasOptionsLimit: Bool {return self._optionsLimit != nil}
  /// Clears the value of `optionsLimit`. Subsequent reads from it will return its default value.
  public mutating func clearOptionsLimit() {self._optionsLimit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _name: String? = nil
  fileprivate var _isRequired: Bool? = nil
  fileprivate var _optionsLimit: Int32? = nil
}

public struct Stremio_Core_Types_ManifestBehaviorHints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var adult: Bool {
    get {return _adult ?? false}
    set {_adult = newValue}
  }
  /// Returns true if `adult` has been explicitly set.
  public var hasAdult: Bool {return self._adult != nil}
  /// Clears the value of `adult`. Subsequent reads from it will return its default value.
  public mutating func clearAdult() {self._adult = nil}

  public var p2P: Bool {
    get {return _p2P ?? false}
    set {_p2P = newValue}
  }
  /// Returns true if `p2P` has been explicitly set.
  public var hasP2P: Bool {return self._p2P != nil}
  /// Clears the value of `p2P`. Subsequent reads from it will return its default value.
  public mutating func clearP2P() {self._p2P = nil}

  public var configurable: Bool {
    get {return _configurable ?? false}
    set {_configurable = newValue}
  }
  /// Returns true if `configurable` has been explicitly set.
  public var hasConfigurable: Bool {return self._configurable != nil}
  /// Clears the value of `configurable`. Subsequent reads from it will return its default value.
  public mutating func clearConfigurable() {self._configurable = nil}

  public var configurationRequired: Bool {
    get {return _configurationRequired ?? false}
    set {_configurationRequired = newValue}
  }
  /// Returns true if `configurationRequired` has been explicitly set.
  public var hasConfigurationRequired: Bool {return self._configurationRequired != nil}
  /// Clears the value of `configurationRequired`. Subsequent reads from it will return its default value.
  public mutating func clearConfigurationRequired() {self._configurationRequired = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _adult: Bool? = nil
  fileprivate var _p2P: Bool? = nil
  fileprivate var _configurable: Bool? = nil
  fileprivate var _configurationRequired: Bool? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stremio_Core_Types_Descriptor: @unchecked Sendable {}
extension Stremio_Core_Types_DescriptorPreview: @unchecked Sendable {}
extension Stremio_Core_Types_DescriptorFlags: @unchecked Sendable {}
extension Stremio_Core_Types_Manifest: @unchecked Sendable {}
extension Stremio_Core_Types_ManifestPreview: @unchecked Sendable {}
extension Stremio_Core_Types_ManifestResource: @unchecked Sendable {}
extension Stremio_Core_Types_ManifestCatalog: @unchecked Sendable {}
extension Stremio_Core_Types_ManifestExtra: @unchecked Sendable {}
extension Stremio_Core_Types_ManifestExtra.OneOf_Extra: @unchecked Sendable {}
extension Stremio_Core_Types_ShortManifestExtra: @unchecked Sendable {}
extension Stremio_Core_Types_FullManifestExtra: @unchecked Sendable {}
extension Stremio_Core_Types_ExtraProp: @unchecked Sendable {}
extension Stremio_Core_Types_ManifestBehaviorHints: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stremio.core.types"

extension Stremio_Core_Types_Descriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Descriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .standard(proto: "transport_url"),
    3: .same(proto: "flags"),
    4: .same(proto: "installed"),
    5: .same(proto: "installable"),
    6: .same(proto: "upgradeable"),
    7: .same(proto: "uninstallable"),
  ]

  fileprivate class _StorageClass {
    var _manifest: Stremio_Core_Types_Manifest? = nil
    var _transportURL: String? = nil
    var _flags: Stremio_Core_Types_DescriptorFlags? = nil
    var _installed: Bool? = nil
    var _installable: Bool? = nil
    var _upgradeable: Bool? = nil
    var _uninstallable: Bool? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _manifest = source._manifest
      _transportURL = source._transportURL
      _flags = source._flags
      _installed = source._installed
      _installable = source._installable
      _upgradeable = source._upgradeable
      _uninstallable = source._uninstallable
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._manifest == nil {return false}
      if _storage._transportURL == nil {return false}
      if _storage._flags == nil {return false}
      if _storage._installed == nil {return false}
      if _storage._installable == nil {return false}
      if _storage._upgradeable == nil {return false}
      if _storage._uninstallable == nil {return false}
      if let v = _storage._manifest, !v.isInitialized {return false}
      if let v = _storage._flags, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._manifest) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._transportURL) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._flags) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._installed) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._installable) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._upgradeable) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._uninstallable) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._manifest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._transportURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._flags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._installed {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._installable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._upgradeable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._uninstallable {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_Descriptor, rhs: Stremio_Core_Types_Descriptor) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._manifest != rhs_storage._manifest {return false}
        if _storage._transportURL != rhs_storage._transportURL {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._installed != rhs_storage._installed {return false}
        if _storage._installable != rhs_storage._installable {return false}
        if _storage._upgradeable != rhs_storage._upgradeable {return false}
        if _storage._uninstallable != rhs_storage._uninstallable {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_DescriptorPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescriptorPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "manifest"),
    2: .standard(proto: "transport_url"),
    3: .same(proto: "installed"),
  ]

  public var isInitialized: Bool {
    if self._manifest == nil {return false}
    if self._transportURL == nil {return false}
    if self._installed == nil {return false}
    if let v = self._manifest, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._manifest) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._transportURL) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._installed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._manifest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._transportURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._installed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_DescriptorPreview, rhs: Stremio_Core_Types_DescriptorPreview) -> Bool {
    if lhs._manifest != rhs._manifest {return false}
    if lhs._transportURL != rhs._transportURL {return false}
    if lhs._installed != rhs._installed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_DescriptorFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescriptorFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "official"),
    2: .same(proto: "protected"),
  ]

  public var isInitialized: Bool {
    if self._official == nil {return false}
    if self._protected == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._official) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._protected) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._official {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._protected {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_DescriptorFlags, rhs: Stremio_Core_Types_DescriptorFlags) -> Bool {
    if lhs._official != rhs._official {return false}
    if lhs._protected != rhs._protected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_Manifest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Manifest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "logo"),
    6: .same(proto: "background"),
    7: .same(proto: "types"),
    8: .standard(proto: "contact_email"),
    9: .same(proto: "resources"),
    10: .standard(proto: "id_prefixes"),
    11: .same(proto: "catalogs"),
    12: .standard(proto: "addon_catalogs"),
    13: .standard(proto: "behavior_hints"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._version == nil {return false}
    if self._name == nil {return false}
    if self._behaviorHints == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.resources) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.catalogs) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.addonCatalogs) {return false}
    if let v = self._behaviorHints, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._logo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._background) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._contactEmail) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.idPrefixes) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.catalogs) }()
      case 12: try { try decoder.decodeRepeatedMessageField(value: &self.addonCatalogs) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._behaviorHints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._logo {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._background {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 7)
    }
    try { if let v = self._contactEmail {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 9)
    }
    if !self.idPrefixes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.idPrefixes, fieldNumber: 10)
    }
    if !self.catalogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.catalogs, fieldNumber: 11)
    }
    if !self.addonCatalogs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addonCatalogs, fieldNumber: 12)
    }
    try { if let v = self._behaviorHints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_Manifest, rhs: Stremio_Core_Types_Manifest) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._version != rhs._version {return false}
    if lhs._name != rhs._name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._logo != rhs._logo {return false}
    if lhs._background != rhs._background {return false}
    if lhs.types != rhs.types {return false}
    if lhs._contactEmail != rhs._contactEmail {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs.idPrefixes != rhs.idPrefixes {return false}
    if lhs.catalogs != rhs.catalogs {return false}
    if lhs.addonCatalogs != rhs.addonCatalogs {return false}
    if lhs._behaviorHints != rhs._behaviorHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_ManifestPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManifestPreview"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
    3: .same(proto: "name"),
    4: .same(proto: "description"),
    5: .same(proto: "logo"),
    6: .same(proto: "background"),
    7: .same(proto: "types"),
    8: .standard(proto: "behavior_hints"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._version == nil {return false}
    if self._name == nil {return false}
    if self._behaviorHints == nil {return false}
    if let v = self._behaviorHints, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._logo) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._background) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._behaviorHints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._logo {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._background {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 7)
    }
    try { if let v = self._behaviorHints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_ManifestPreview, rhs: Stremio_Core_Types_ManifestPreview) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._version != rhs._version {return false}
    if lhs._name != rhs._name {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs._logo != rhs._logo {return false}
    if lhs._background != rhs._background {return false}
    if lhs.types != rhs.types {return false}
    if lhs._behaviorHints != rhs._behaviorHints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_ManifestResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManifestResource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "types"),
    3: .standard(proto: "id_prefixes"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.types) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.idPrefixes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.types.isEmpty {
      try visitor.visitRepeatedStringField(value: self.types, fieldNumber: 2)
    }
    if !self.idPrefixes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.idPrefixes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_ManifestResource, rhs: Stremio_Core_Types_ManifestResource) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.types != rhs.types {return false}
    if lhs.idPrefixes != rhs.idPrefixes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_ManifestCatalog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManifestCatalog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "extra"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._type == nil {return false}
    if self._extra == nil {return false}
    if let v = self._extra, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._extra) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._extra {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_ManifestCatalog, rhs: Stremio_Core_Types_ManifestCatalog) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._type != rhs._type {return false}
    if lhs._name != rhs._name {return false}
    if lhs._extra != rhs._extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_ManifestExtra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManifestExtra"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "full"),
    2: .same(proto: "short"),
  ]

  public var isInitialized: Bool {
    if let v = self.extra, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Stremio_Core_Types_FullManifestExtra?
        var hadOneofValue = false
        if let current = self.extra {
          hadOneofValue = true
          if case .full(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.extra = .full(v)
        }
      }()
      case 2: try {
        var v: Stremio_Core_Types_ShortManifestExtra?
        var hadOneofValue = false
        if let current = self.extra {
          hadOneofValue = true
          if case .short(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.extra = .short(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.extra {
    case .full?: try {
      guard case .full(let v)? = self.extra else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .short?: try {
      guard case .short(let v)? = self.extra else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_ManifestExtra, rhs: Stremio_Core_Types_ManifestExtra) -> Bool {
    if lhs.extra != rhs.extra {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_ShortManifestExtra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShortManifestExtra"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "required"),
    2: .same(proto: "supported"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.required) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.supported) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.required.isEmpty {
      try visitor.visitRepeatedStringField(value: self.required, fieldNumber: 1)
    }
    if !self.supported.isEmpty {
      try visitor.visitRepeatedStringField(value: self.supported, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_ShortManifestExtra, rhs: Stremio_Core_Types_ShortManifestExtra) -> Bool {
    if lhs.required != rhs.required {return false}
    if lhs.supported != rhs.supported {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_FullManifestExtra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullManifestExtra"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "props"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.props) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.props) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.props.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.props, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_FullManifestExtra, rhs: Stremio_Core_Types_FullManifestExtra) -> Bool {
    if lhs.props != rhs.props {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_ExtraProp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExtraProp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "is_required"),
    3: .same(proto: "options"),
    4: .standard(proto: "options_limit"),
  ]

  public var isInitialized: Bool {
    if self._name == nil {return false}
    if self._isRequired == nil {return false}
    if self._optionsLimit == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isRequired) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.options) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._optionsLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isRequired {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    if !self.options.isEmpty {
      try visitor.visitRepeatedStringField(value: self.options, fieldNumber: 3)
    }
    try { if let v = self._optionsLimit {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_ExtraProp, rhs: Stremio_Core_Types_ExtraProp) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._isRequired != rhs._isRequired {return false}
    if lhs.options != rhs.options {return false}
    if lhs._optionsLimit != rhs._optionsLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Types_ManifestBehaviorHints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManifestBehaviorHints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "adult"),
    2: .same(proto: "p2p"),
    3: .same(proto: "configurable"),
    4: .standard(proto: "configuration_required"),
  ]

  public var isInitialized: Bool {
    if self._adult == nil {return false}
    if self._p2P == nil {return false}
    if self._configurable == nil {return false}
    if self._configurationRequired == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._adult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._p2P) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._configurable) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._configurationRequired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._adult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._p2P {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._configurable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._configurationRequired {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Types_ManifestBehaviorHints, rhs: Stremio_Core_Types_ManifestBehaviorHints) -> Bool {
    if lhs._adult != rhs._adult {return false}
    if lhs._p2P != rhs._p2P {return false}
    if lhs._configurable != rhs._configurable {return false}
    if lhs._configurationRequired != rhs._configurationRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
