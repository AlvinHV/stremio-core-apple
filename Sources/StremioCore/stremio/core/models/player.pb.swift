// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: stremio/core/models/player.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Stremio_Core_Models_Player {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var selected: Stremio_Core_Models_Player.Selected {
    get {return _storage._selected ?? Stremio_Core_Models_Player.Selected()}
    set {_uniqueStorage()._selected = newValue}
  }
  /// Returns true if `selected` has been explicitly set.
  public var hasSelected: Bool {return _storage._selected != nil}
  /// Clears the value of `selected`. Subsequent reads from it will return its default value.
  public mutating func clearSelected() {_uniqueStorage()._selected = nil}

  public var videoParams: Stremio_Core_Models_Player.VideoParams {
    get {return _storage._videoParams ?? Stremio_Core_Models_Player.VideoParams()}
    set {_uniqueStorage()._videoParams = newValue}
  }
  /// Returns true if `videoParams` has been explicitly set.
  public var hasVideoParams: Bool {return _storage._videoParams != nil}
  /// Clears the value of `videoParams`. Subsequent reads from it will return its default value.
  public mutating func clearVideoParams() {_uniqueStorage()._videoParams = nil}

  public var metaItem: Stremio_Core_Models_LoadableMetaItem {
    get {return _storage._metaItem ?? Stremio_Core_Models_LoadableMetaItem()}
    set {_uniqueStorage()._metaItem = newValue}
  }
  /// Returns true if `metaItem` has been explicitly set.
  public var hasMetaItem: Bool {return _storage._metaItem != nil}
  /// Clears the value of `metaItem`. Subsequent reads from it will return its default value.
  public mutating func clearMetaItem() {_uniqueStorage()._metaItem = nil}

  public var subtitles: [Stremio_Core_Models_LoadableSubtitles] {
    get {return _storage._subtitles}
    set {_uniqueStorage()._subtitles = newValue}
  }

  public var nextVideo: Stremio_Core_Types_Video {
    get {return _storage._nextVideo ?? Stremio_Core_Types_Video()}
    set {_uniqueStorage()._nextVideo = newValue}
  }
  /// Returns true if `nextVideo` has been explicitly set.
  public var hasNextVideo: Bool {return _storage._nextVideo != nil}
  /// Clears the value of `nextVideo`. Subsequent reads from it will return its default value.
  public mutating func clearNextVideo() {_uniqueStorage()._nextVideo = nil}

  public var seriesInfo: Stremio_Core_Types_Video.SeriesInfo {
    get {return _storage._seriesInfo ?? Stremio_Core_Types_Video.SeriesInfo()}
    set {_uniqueStorage()._seriesInfo = newValue}
  }
  /// Returns true if `seriesInfo` has been explicitly set.
  public var hasSeriesInfo: Bool {return _storage._seriesInfo != nil}
  /// Clears the value of `seriesInfo`. Subsequent reads from it will return its default value.
  public mutating func clearSeriesInfo() {_uniqueStorage()._seriesInfo = nil}

  public var libraryItem: Stremio_Core_Types_LibraryItem {
    get {return _storage._libraryItem ?? Stremio_Core_Types_LibraryItem()}
    set {_uniqueStorage()._libraryItem = newValue}
  }
  /// Returns true if `libraryItem` has been explicitly set.
  public var hasLibraryItem: Bool {return _storage._libraryItem != nil}
  /// Clears the value of `libraryItem`. Subsequent reads from it will return its default value.
  public mutating func clearLibraryItem() {_uniqueStorage()._libraryItem = nil}

  public var streamState: Stremio_Core_Models_Player.StreamState {
    get {return _storage._streamState ?? Stremio_Core_Models_Player.StreamState()}
    set {_uniqueStorage()._streamState = newValue}
  }
  /// Returns true if `streamState` has been explicitly set.
  public var hasStreamState: Bool {return _storage._streamState != nil}
  /// Clears the value of `streamState`. Subsequent reads from it will return its default value.
  public mutating func clearStreamState() {_uniqueStorage()._streamState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct VideoParams {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hash: String {
      get {return _hash ?? String()}
      set {_hash = newValue}
    }
    /// Returns true if `hash` has been explicitly set.
    public var hasHash: Bool {return self._hash != nil}
    /// Clears the value of `hash`. Subsequent reads from it will return its default value.
    public mutating func clearHash() {self._hash = nil}

    public var size: Int64 {
      get {return _size ?? 0}
      set {_size = newValue}
    }
    /// Returns true if `size` has been explicitly set.
    public var hasSize: Bool {return self._size != nil}
    /// Clears the value of `size`. Subsequent reads from it will return its default value.
    public mutating func clearSize() {self._size = nil}

    public var filename: String {
      get {return _filename ?? String()}
      set {_filename = newValue}
    }
    /// Returns true if `filename` has been explicitly set.
    public var hasFilename: Bool {return self._filename != nil}
    /// Clears the value of `filename`. Subsequent reads from it will return its default value.
    public mutating func clearFilename() {self._filename = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _hash: String? = nil
    fileprivate var _size: Int64? = nil
    fileprivate var _filename: String? = nil
  }

  public struct StreamState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var subtitleTrack: Stremio_Core_Models_Player.SubtitleTrack {
      get {return _subtitleTrack ?? Stremio_Core_Models_Player.SubtitleTrack()}
      set {_subtitleTrack = newValue}
    }
    /// Returns true if `subtitleTrack` has been explicitly set.
    public var hasSubtitleTrack: Bool {return self._subtitleTrack != nil}
    /// Clears the value of `subtitleTrack`. Subsequent reads from it will return its default value.
    public mutating func clearSubtitleTrack() {self._subtitleTrack = nil}

    public var subtitleDelay: Int64 {
      get {return _subtitleDelay ?? 0}
      set {_subtitleDelay = newValue}
    }
    /// Returns true if `subtitleDelay` has been explicitly set.
    public var hasSubtitleDelay: Bool {return self._subtitleDelay != nil}
    /// Clears the value of `subtitleDelay`. Subsequent reads from it will return its default value.
    public mutating func clearSubtitleDelay() {self._subtitleDelay = nil}

    public var audioTrack: Stremio_Core_Models_Player.AudioTrack {
      get {return _audioTrack ?? Stremio_Core_Models_Player.AudioTrack()}
      set {_audioTrack = newValue}
    }
    /// Returns true if `audioTrack` has been explicitly set.
    public var hasAudioTrack: Bool {return self._audioTrack != nil}
    /// Clears the value of `audioTrack`. Subsequent reads from it will return its default value.
    public mutating func clearAudioTrack() {self._audioTrack = nil}

    public var audioDelay: Int64 {
      get {return _audioDelay ?? 0}
      set {_audioDelay = newValue}
    }
    /// Returns true if `audioDelay` has been explicitly set.
    public var hasAudioDelay: Bool {return self._audioDelay != nil}
    /// Clears the value of `audioDelay`. Subsequent reads from it will return its default value.
    public mutating func clearAudioDelay() {self._audioDelay = nil}

    public var playbackSpeed: Float {
      get {return _playbackSpeed ?? 0}
      set {_playbackSpeed = newValue}
    }
    /// Returns true if `playbackSpeed` has been explicitly set.
    public var hasPlaybackSpeed: Bool {return self._playbackSpeed != nil}
    /// Clears the value of `playbackSpeed`. Subsequent reads from it will return its default value.
    public mutating func clearPlaybackSpeed() {self._playbackSpeed = nil}

    public var playerType: String {
      get {return _playerType ?? String()}
      set {_playerType = newValue}
    }
    /// Returns true if `playerType` has been explicitly set.
    public var hasPlayerType: Bool {return self._playerType != nil}
    /// Clears the value of `playerType`. Subsequent reads from it will return its default value.
    public mutating func clearPlayerType() {self._playerType = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _subtitleTrack: Stremio_Core_Models_Player.SubtitleTrack? = nil
    fileprivate var _subtitleDelay: Int64? = nil
    fileprivate var _audioTrack: Stremio_Core_Models_Player.AudioTrack? = nil
    fileprivate var _audioDelay: Int64? = nil
    fileprivate var _playbackSpeed: Float? = nil
    fileprivate var _playerType: String? = nil
  }

  public struct SubtitleTrack {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var embedded: Bool {
      get {return _embedded ?? false}
      set {_embedded = newValue}
    }
    /// Returns true if `embedded` has been explicitly set.
    public var hasEmbedded: Bool {return self._embedded != nil}
    /// Clears the value of `embedded`. Subsequent reads from it will return its default value.
    public mutating func clearEmbedded() {self._embedded = nil}

    public var language: String {
      get {return _language ?? String()}
      set {_language = newValue}
    }
    /// Returns true if `language` has been explicitly set.
    public var hasLanguage: Bool {return self._language != nil}
    /// Clears the value of `language`. Subsequent reads from it will return its default value.
    public mutating func clearLanguage() {self._language = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
    fileprivate var _embedded: Bool? = nil
    fileprivate var _language: String? = nil
  }

  public struct AudioTrack {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    public var language: String {
      get {return _language ?? String()}
      set {_language = newValue}
    }
    /// Returns true if `language` has been explicitly set.
    public var hasLanguage: Bool {return self._language != nil}
    /// Clears the value of `language`. Subsequent reads from it will return its default value.
    public mutating func clearLanguage() {self._language = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _id: String? = nil
    fileprivate var _language: String? = nil
  }

  public struct Selected {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var stream: Stremio_Core_Types_Stream {
      get {return _stream ?? Stremio_Core_Types_Stream()}
      set {_stream = newValue}
    }
    /// Returns true if `stream` has been explicitly set.
    public var hasStream: Bool {return self._stream != nil}
    /// Clears the value of `stream`. Subsequent reads from it will return its default value.
    public mutating func clearStream() {self._stream = nil}

    public var streamRequest: Stremio_Core_Types_ResourceRequest {
      get {return _streamRequest ?? Stremio_Core_Types_ResourceRequest()}
      set {_streamRequest = newValue}
    }
    /// Returns true if `streamRequest` has been explicitly set.
    public var hasStreamRequest: Bool {return self._streamRequest != nil}
    /// Clears the value of `streamRequest`. Subsequent reads from it will return its default value.
    public mutating func clearStreamRequest() {self._streamRequest = nil}

    public var metaRequest: Stremio_Core_Types_ResourceRequest {
      get {return _metaRequest ?? Stremio_Core_Types_ResourceRequest()}
      set {_metaRequest = newValue}
    }
    /// Returns true if `metaRequest` has been explicitly set.
    public var hasMetaRequest: Bool {return self._metaRequest != nil}
    /// Clears the value of `metaRequest`. Subsequent reads from it will return its default value.
    public mutating func clearMetaRequest() {self._metaRequest = nil}

    public var subtitlesPath: Stremio_Core_Types_ResourcePath {
      get {return _subtitlesPath ?? Stremio_Core_Types_ResourcePath()}
      set {_subtitlesPath = newValue}
    }
    /// Returns true if `subtitlesPath` has been explicitly set.
    public var hasSubtitlesPath: Bool {return self._subtitlesPath != nil}
    /// Clears the value of `subtitlesPath`. Subsequent reads from it will return its default value.
    public mutating func clearSubtitlesPath() {self._subtitlesPath = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _stream: Stremio_Core_Types_Stream? = nil
    fileprivate var _streamRequest: Stremio_Core_Types_ResourceRequest? = nil
    fileprivate var _metaRequest: Stremio_Core_Types_ResourceRequest? = nil
    fileprivate var _subtitlesPath: Stremio_Core_Types_ResourcePath? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Stremio_Core_Models_LoadableSubtitles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  public var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  public mutating func clearTitle() {self._title = nil}

  public var request: Stremio_Core_Types_ResourceRequest {
    get {return _request ?? Stremio_Core_Types_ResourceRequest()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  public var content: Stremio_Core_Models_LoadableSubtitles.OneOf_Content? = nil

  public var loading: Stremio_Core_Models_Loading {
    get {
      if case .loading(let v)? = content {return v}
      return Stremio_Core_Models_Loading()
    }
    set {content = .loading(newValue)}
  }

  public var error: Stremio_Core_Models_Error {
    get {
      if case .error(let v)? = content {return v}
      return Stremio_Core_Models_Error()
    }
    set {content = .error(newValue)}
  }

  public var ready: Stremio_Core_Models_Subtitles {
    get {
      if case .ready(let v)? = content {return v}
      return Stremio_Core_Models_Subtitles()
    }
    set {content = .ready(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case loading(Stremio_Core_Models_Loading)
    case error(Stremio_Core_Models_Error)
    case ready(Stremio_Core_Models_Subtitles)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .error: return {
        guard case .error(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .ready: return {
        guard case .ready(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    public static func ==(lhs: Stremio_Core_Models_LoadableSubtitles.OneOf_Content, rhs: Stremio_Core_Models_LoadableSubtitles.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.loading, .loading): return {
        guard case .loading(let l) = lhs, case .loading(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.error, .error): return {
        guard case .error(let l) = lhs, case .error(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ready, .ready): return {
        guard case .ready(let l) = lhs, case .ready(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _title: String? = nil
  fileprivate var _request: Stremio_Core_Types_ResourceRequest? = nil
}

public struct Stremio_Core_Models_Subtitles {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subtitles: [Stremio_Core_Types_Subtitle] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Stremio_Core_Models_Player: @unchecked Sendable {}
extension Stremio_Core_Models_Player.VideoParams: @unchecked Sendable {}
extension Stremio_Core_Models_Player.StreamState: @unchecked Sendable {}
extension Stremio_Core_Models_Player.SubtitleTrack: @unchecked Sendable {}
extension Stremio_Core_Models_Player.AudioTrack: @unchecked Sendable {}
extension Stremio_Core_Models_Player.Selected: @unchecked Sendable {}
extension Stremio_Core_Models_LoadableSubtitles: @unchecked Sendable {}
extension Stremio_Core_Models_LoadableSubtitles.OneOf_Content: @unchecked Sendable {}
extension Stremio_Core_Models_Subtitles: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "stremio.core.models"

extension Stremio_Core_Models_Player: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Player"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "selected"),
    2: .standard(proto: "video_params"),
    3: .standard(proto: "meta_item"),
    4: .same(proto: "subtitles"),
    5: .standard(proto: "next_video"),
    6: .standard(proto: "series_info"),
    7: .standard(proto: "library_item"),
    8: .standard(proto: "stream_state"),
  ]

  fileprivate class _StorageClass {
    var _selected: Stremio_Core_Models_Player.Selected? = nil
    var _videoParams: Stremio_Core_Models_Player.VideoParams? = nil
    var _metaItem: Stremio_Core_Models_LoadableMetaItem? = nil
    var _subtitles: [Stremio_Core_Models_LoadableSubtitles] = []
    var _nextVideo: Stremio_Core_Types_Video? = nil
    var _seriesInfo: Stremio_Core_Types_Video.SeriesInfo? = nil
    var _libraryItem: Stremio_Core_Types_LibraryItem? = nil
    var _streamState: Stremio_Core_Models_Player.StreamState? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _selected = source._selected
      _videoParams = source._videoParams
      _metaItem = source._metaItem
      _subtitles = source._subtitles
      _nextVideo = source._nextVideo
      _seriesInfo = source._seriesInfo
      _libraryItem = source._libraryItem
      _streamState = source._streamState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._selected, !v.isInitialized {return false}
      if let v = _storage._metaItem, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._subtitles) {return false}
      if let v = _storage._nextVideo, !v.isInitialized {return false}
      if let v = _storage._seriesInfo, !v.isInitialized {return false}
      if let v = _storage._libraryItem, !v.isInitialized {return false}
      if let v = _storage._streamState, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._selected) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._videoParams) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._metaItem) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._subtitles) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._nextVideo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._seriesInfo) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._libraryItem) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._streamState) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._selected {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._videoParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._metaItem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._subtitles.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._subtitles, fieldNumber: 4)
      }
      try { if let v = _storage._nextVideo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._seriesInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._libraryItem {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._streamState {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Models_Player, rhs: Stremio_Core_Models_Player) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._selected != rhs_storage._selected {return false}
        if _storage._videoParams != rhs_storage._videoParams {return false}
        if _storage._metaItem != rhs_storage._metaItem {return false}
        if _storage._subtitles != rhs_storage._subtitles {return false}
        if _storage._nextVideo != rhs_storage._nextVideo {return false}
        if _storage._seriesInfo != rhs_storage._seriesInfo {return false}
        if _storage._libraryItem != rhs_storage._libraryItem {return false}
        if _storage._streamState != rhs_storage._streamState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Models_Player.VideoParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Models_Player.protoMessageName + ".VideoParams"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "size"),
    3: .same(proto: "filename"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._size) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._filename) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._filename {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Models_Player.VideoParams, rhs: Stremio_Core_Models_Player.VideoParams) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._size != rhs._size {return false}
    if lhs._filename != rhs._filename {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Models_Player.StreamState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Models_Player.protoMessageName + ".StreamState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subtitle_track"),
    2: .standard(proto: "subtitle_delay"),
    3: .standard(proto: "audio_track"),
    4: .standard(proto: "audio_delay"),
    5: .standard(proto: "playback_speed"),
    6: .standard(proto: "player_type"),
  ]

  public var isInitialized: Bool {
    if let v = self._subtitleTrack, !v.isInitialized {return false}
    if let v = self._audioTrack, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subtitleTrack) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._subtitleDelay) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._audioTrack) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._audioDelay) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._playbackSpeed) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._playerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subtitleTrack {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._subtitleDelay {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._audioTrack {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._audioDelay {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._playbackSpeed {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._playerType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Models_Player.StreamState, rhs: Stremio_Core_Models_Player.StreamState) -> Bool {
    if lhs._subtitleTrack != rhs._subtitleTrack {return false}
    if lhs._subtitleDelay != rhs._subtitleDelay {return false}
    if lhs._audioTrack != rhs._audioTrack {return false}
    if lhs._audioDelay != rhs._audioDelay {return false}
    if lhs._playbackSpeed != rhs._playbackSpeed {return false}
    if lhs._playerType != rhs._playerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Models_Player.SubtitleTrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Models_Player.protoMessageName + ".SubtitleTrack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "embedded"),
    3: .same(proto: "language"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._embedded == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._embedded) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._embedded {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._language {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Models_Player.SubtitleTrack, rhs: Stremio_Core_Models_Player.SubtitleTrack) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._embedded != rhs._embedded {return false}
    if lhs._language != rhs._language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Models_Player.AudioTrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Models_Player.protoMessageName + ".AudioTrack"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "language"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._language) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._language {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Models_Player.AudioTrack, rhs: Stremio_Core_Models_Player.AudioTrack) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._language != rhs._language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Models_Player.Selected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Stremio_Core_Models_Player.protoMessageName + ".Selected"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stream"),
    2: .standard(proto: "stream_request"),
    3: .standard(proto: "meta_request"),
    4: .standard(proto: "subtitles_path"),
  ]

  public var isInitialized: Bool {
    if self._stream == nil {return false}
    if let v = self._stream, !v.isInitialized {return false}
    if let v = self._streamRequest, !v.isInitialized {return false}
    if let v = self._metaRequest, !v.isInitialized {return false}
    if let v = self._subtitlesPath, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stream) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._streamRequest) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metaRequest) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._subtitlesPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stream {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._streamRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._metaRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._subtitlesPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Models_Player.Selected, rhs: Stremio_Core_Models_Player.Selected) -> Bool {
    if lhs._stream != rhs._stream {return false}
    if lhs._streamRequest != rhs._streamRequest {return false}
    if lhs._metaRequest != rhs._metaRequest {return false}
    if lhs._subtitlesPath != rhs._subtitlesPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Models_LoadableSubtitles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadableSubtitles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "request"),
    3: .same(proto: "loading"),
    4: .same(proto: "error"),
    5: .same(proto: "ready"),
  ]

  public var isInitialized: Bool {
    if self._title == nil {return false}
    if self._request == nil {return false}
    if let v = self._request, !v.isInitialized {return false}
    if let v = self.content, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 3: try {
        var v: Stremio_Core_Models_Loading?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .loading(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .loading(v)
        }
      }()
      case 4: try {
        var v: Stremio_Core_Models_Error?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .error(v)
        }
      }()
      case 5: try {
        var v: Stremio_Core_Models_Subtitles?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .ready(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .ready(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.content {
    case .loading?: try {
      guard case .loading(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .error?: try {
      guard case .error(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .ready?: try {
      guard case .ready(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Models_LoadableSubtitles, rhs: Stremio_Core_Models_LoadableSubtitles) -> Bool {
    if lhs._title != rhs._title {return false}
    if lhs._request != rhs._request {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Stremio_Core_Models_Subtitles: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Subtitles"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subtitles"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.subtitles) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subtitles) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subtitles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subtitles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Stremio_Core_Models_Subtitles, rhs: Stremio_Core_Models_Subtitles) -> Bool {
    if lhs.subtitles != rhs.subtitles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
